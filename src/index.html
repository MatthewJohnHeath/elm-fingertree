<!DOCTYPE HTML>
<html><head><meta charset="UTF-8"><title>Container</title><style>html,head,body { padding:0; margin:0; }
body { font-family: calibri, helvetica, arial, sans-serif; }</style><script type="text/javascript">
(function() {
'use strict';

function F2(fun)
{
  function wrapper(a) { return function(b) { return fun(a,b); }; }
  wrapper.arity = 2;
  wrapper.func = fun;
  return wrapper;
}

function F3(fun)
{
  function wrapper(a) {
    return function(b) { return function(c) { return fun(a, b, c); }; };
  }
  wrapper.arity = 3;
  wrapper.func = fun;
  return wrapper;
}

function F4(fun)
{
  function wrapper(a) { return function(b) { return function(c) {
    return function(d) { return fun(a, b, c, d); }; }; };
  }
  wrapper.arity = 4;
  wrapper.func = fun;
  return wrapper;
}

function F5(fun)
{
  function wrapper(a) { return function(b) { return function(c) {
    return function(d) { return function(e) { return fun(a, b, c, d, e); }; }; }; };
  }
  wrapper.arity = 5;
  wrapper.func = fun;
  return wrapper;
}

function F6(fun)
{
  function wrapper(a) { return function(b) { return function(c) {
    return function(d) { return function(e) { return function(f) {
    return fun(a, b, c, d, e, f); }; }; }; }; };
  }
  wrapper.arity = 6;
  wrapper.func = fun;
  return wrapper;
}

function F7(fun)
{
  function wrapper(a) { return function(b) { return function(c) {
    return function(d) { return function(e) { return function(f) {
    return function(g) { return fun(a, b, c, d, e, f, g); }; }; }; }; }; };
  }
  wrapper.arity = 7;
  wrapper.func = fun;
  return wrapper;
}

function F8(fun)
{
  function wrapper(a) { return function(b) { return function(c) {
    return function(d) { return function(e) { return function(f) {
    return function(g) { return function(h) {
    return fun(a, b, c, d, e, f, g, h); }; }; }; }; }; }; };
  }
  wrapper.arity = 8;
  wrapper.func = fun;
  return wrapper;
}

function F9(fun)
{
  function wrapper(a) { return function(b) { return function(c) {
    return function(d) { return function(e) { return function(f) {
    return function(g) { return function(h) { return function(i) {
    return fun(a, b, c, d, e, f, g, h, i); }; }; }; }; }; }; }; };
  }
  wrapper.arity = 9;
  wrapper.func = fun;
  return wrapper;
}

function A2(fun, a, b)
{
  return fun.arity === 2
    ? fun.func(a, b)
    : fun(a)(b);
}
function A3(fun, a, b, c)
{
  return fun.arity === 3
    ? fun.func(a, b, c)
    : fun(a)(b)(c);
}
function A4(fun, a, b, c, d)
{
  return fun.arity === 4
    ? fun.func(a, b, c, d)
    : fun(a)(b)(c)(d);
}
function A5(fun, a, b, c, d, e)
{
  return fun.arity === 5
    ? fun.func(a, b, c, d, e)
    : fun(a)(b)(c)(d)(e);
}
function A6(fun, a, b, c, d, e, f)
{
  return fun.arity === 6
    ? fun.func(a, b, c, d, e, f)
    : fun(a)(b)(c)(d)(e)(f);
}
function A7(fun, a, b, c, d, e, f, g)
{
  return fun.arity === 7
    ? fun.func(a, b, c, d, e, f, g)
    : fun(a)(b)(c)(d)(e)(f)(g);
}
function A8(fun, a, b, c, d, e, f, g, h)
{
  return fun.arity === 8
    ? fun.func(a, b, c, d, e, f, g, h)
    : fun(a)(b)(c)(d)(e)(f)(g)(h);
}
function A9(fun, a, b, c, d, e, f, g, h, i)
{
  return fun.arity === 9
    ? fun.func(a, b, c, d, e, f, g, h, i)
    : fun(a)(b)(c)(d)(e)(f)(g)(h)(i);
}
//import Native.Utils //

var _elm_lang$core$Native_Basics = function() {

function div(a, b)
{
	return (a / b) | 0;
}
function rem(a, b)
{
	return a % b;
}
function mod(a, b)
{
	if (b === 0)
	{
		throw new Error('Cannot perform mod 0. Division by zero error.');
	}
	var r = a % b;
	var m = a === 0 ? 0 : (b > 0 ? (a >= 0 ? r : r + b) : -mod(-a, -b));

	return m === b ? 0 : m;
}
function logBase(base, n)
{
	return Math.log(n) / Math.log(base);
}
function negate(n)
{
	return -n;
}
function abs(n)
{
	return n < 0 ? -n : n;
}

function min(a, b)
{
	return _elm_lang$core$Native_Utils.cmp(a, b) < 0 ? a : b;
}
function max(a, b)
{
	return _elm_lang$core$Native_Utils.cmp(a, b) > 0 ? a : b;
}
function clamp(lo, hi, n)
{
	return _elm_lang$core$Native_Utils.cmp(n, lo) < 0
		? lo
		: _elm_lang$core$Native_Utils.cmp(n, hi) > 0
			? hi
			: n;
}

var ord = ['LT', 'EQ', 'GT'];

function compare(x, y)
{
	return { ctor: ord[_elm_lang$core$Native_Utils.cmp(x, y) + 1] };
}

function xor(a, b)
{
	return a !== b;
}
function not(b)
{
	return !b;
}
function isInfinite(n)
{
	return n === Infinity || n === -Infinity;
}

function truncate(n)
{
	return n | 0;
}

function degrees(d)
{
	return d * Math.PI / 180;
}
function turns(t)
{
	return 2 * Math.PI * t;
}
function fromPolar(point)
{
	var r = point._0;
	var t = point._1;
	return _elm_lang$core$Native_Utils.Tuple2(r * Math.cos(t), r * Math.sin(t));
}
function toPolar(point)
{
	var x = point._0;
	var y = point._1;
	return _elm_lang$core$Native_Utils.Tuple2(Math.sqrt(x * x + y * y), Math.atan2(y, x));
}

return {
	div: F2(div),
	rem: F2(rem),
	mod: F2(mod),

	pi: Math.PI,
	e: Math.E,
	cos: Math.cos,
	sin: Math.sin,
	tan: Math.tan,
	acos: Math.acos,
	asin: Math.asin,
	atan: Math.atan,
	atan2: F2(Math.atan2),

	degrees: degrees,
	turns: turns,
	fromPolar: fromPolar,
	toPolar: toPolar,

	sqrt: Math.sqrt,
	logBase: F2(logBase),
	negate: negate,
	abs: abs,
	min: F2(min),
	max: F2(max),
	clamp: F3(clamp),
	compare: F2(compare),

	xor: F2(xor),
	not: not,

	truncate: truncate,
	ceiling: Math.ceil,
	floor: Math.floor,
	round: Math.round,
	toFloat: function(x) { return x; },
	isNaN: isNaN,
	isInfinite: isInfinite
};

}();//import //

var _elm_lang$core$Native_Utils = function() {

// COMPARISONS

function eq(rootX, rootY)
{
	var stack = [{ x: rootX, y: rootY }];
	while (stack.length > 0)
	{
		var front = stack.pop();
		var x = front.x;
		var y = front.y;
		if (x === y)
		{
			continue;
		}
		if (typeof x === 'object')
		{
			var c = 0;
			for (var key in x)
			{
				++c;
				if (!(key in y))
				{
					return false;
				}
				if (key === 'ctor')
				{
					continue;
				}
				stack.push({ x: x[key], y: y[key] });
			}
			if ('ctor' in x)
			{
				stack.push({ x: x.ctor, y: y.ctor});
			}
			if (c !== Object.keys(y).length)
			{
				return false;
			}
		}
		else if (typeof x === 'function')
		{
			throw new Error('Equality error: general function equality is ' +
							'undecidable, and therefore, unsupported');
		}
		else
		{
			return false;
		}
	}
	return true;
}

// Code in Generate/JavaScript.hs, Basics.js, and List.js depends on
// the particular integer values assigned to LT, EQ, and GT.

var LT = -1, EQ = 0, GT = 1;

function cmp(x, y)
{
	var ord;
	if (typeof x !== 'object')
	{
		return x === y ? EQ : x < y ? LT : GT;
	}
	else if (x instanceof String)
	{
		var a = x.valueOf();
		var b = y.valueOf();
		return a === b
			? EQ
			: a < b
				? LT
				: GT;
	}
	else if (x.ctor === '::' || x.ctor === '[]')
	{
		while (true)
		{
			if (x.ctor === '[]' && y.ctor === '[]')
			{
				return EQ;
			}
			if (x.ctor !== y.ctor)
			{
				return x.ctor === '[]' ? LT : GT;
			}
			ord = cmp(x._0, y._0);
			if (ord !== EQ)
			{
				return ord;
			}
			x = x._1;
			y = y._1;
		}
	}
	else if (x.ctor.slice(0, 6) === '_Tuple')
	{
		var n = x.ctor.slice(6) - 0;
		var err = 'cannot compare tuples with more than 6 elements.';
		if (n === 0) return EQ;
		if (n >= 1) { ord = cmp(x._0, y._0); if (ord !== EQ) return ord;
		if (n >= 2) { ord = cmp(x._1, y._1); if (ord !== EQ) return ord;
		if (n >= 3) { ord = cmp(x._2, y._2); if (ord !== EQ) return ord;
		if (n >= 4) { ord = cmp(x._3, y._3); if (ord !== EQ) return ord;
		if (n >= 5) { ord = cmp(x._4, y._4); if (ord !== EQ) return ord;
		if (n >= 6) { ord = cmp(x._5, y._5); if (ord !== EQ) return ord;
		if (n >= 7) throw new Error('Comparison error: ' + err); } } } } } }
		return EQ;
	}
	else
	{
		throw new Error('Comparison error: comparison is only defined on ints, ' +
						'floats, times, chars, strings, lists of comparable values, ' +
						'and tuples of comparable values.');
	}
}


// COMMON VALUES

var Tuple0 = {
	ctor: '_Tuple0'
};

function Tuple2(x, y)
{
	return {
		ctor: '_Tuple2',
		_0: x,
		_1: y
	};
}

function chr(c)
{
	return new String(c);
}


// GUID

var count = 0;
function guid(_)
{
	return count++;
}


// RECORDS

function update(oldRecord, updatedFields)
{
	var newRecord = {};
	for (var key in oldRecord)
	{
		var value = (key in updatedFields) ? updatedFields[key] : oldRecord[key];
		newRecord[key] = value;
	}
	return newRecord;
}


//// LIST STUFF ////

var Nil = { ctor: '[]' };

function Cons(hd, tl)
{
	return {
		ctor: '::',
		_0: hd,
		_1: tl
	};
}

function append(xs, ys)
{
	// append Strings
	if (typeof xs === 'string')
	{
		return xs + ys;
	}

	// append Lists
	if (xs.ctor === '[]')
	{
		return ys;
	}
	var root = Cons(xs._0, Nil);
	var curr = root;
	xs = xs._1;
	while (xs.ctor !== '[]')
	{
		curr._1 = Cons(xs._0, Nil);
		xs = xs._1;
		curr = curr._1;
	}
	curr._1 = ys;
	return root;
}


// CRASHES

function crash(moduleName, region)
{
	return function(message) {
		throw new Error(
			'Ran into a `Debug.crash` in module `' + moduleName + '` ' + regionToString(region) + '\n'
			+ 'The message provided by the code author is:\n\n    '
			+ message
		);
	};
}

function crashCase(moduleName, region, value)
{
	return function(message) {
		throw new Error(
			'Ran into a `Debug.crash` in module `' + moduleName + '`\n\n'
			+ 'This was caused by the `case` expression ' + regionToString(region) + '.\n'
			+ 'One of the branches ended with a crash and the following value got through:\n\n    ' + toString(value) + '\n\n'
			+ 'The message provided by the code author is:\n\n    '
			+ message
		);
	};
}

function regionToString(region)
{
	if (region.start.line == region.end.line)
	{
		return 'on line ' + region.start.line;
	}
	return 'between lines ' + region.start.line + ' and ' + region.end.line;
}


// TO STRING

function toString(v)
{
	var type = typeof v;
	if (type === 'function')
	{
		var name = v.func ? v.func.name : v.name;
		return '<function' + (name === '' ? '' : ':') + name + '>';
	}

	if (type === 'boolean')
	{
		return v ? 'True' : 'False';
	}

	if (type === 'number')
	{
		return v + '';
	}

	if (v instanceof String)
	{
		return '\'' + addSlashes(v, true) + '\'';
	}

	if (type === 'string')
	{
		return '"' + addSlashes(v, false) + '"';
	}

	if (v === null)
	{
		return 'null';
	}

	if (type === 'object' && 'ctor' in v)
	{
		var ctorStarter = v.ctor.substring(0, 5);

		if (ctorStarter === '_Tupl')
		{
			var output = [];
			for (var k in v)
			{
				if (k === 'ctor') continue;
				output.push(toString(v[k]));
			}
			return '(' + output.join(',') + ')';
		}

		if (ctorStarter === '_Task')
		{
			return '<task>'
		}

		if (v.ctor === '_Array')
		{
			var list = _elm_lang$core$Array$toList(v);
			return 'Array.fromList ' + toString(list);
		}

		if (v.ctor === '<decoder>')
		{
			return '<decoder>';
		}

		if (v.ctor === '_Process')
		{
			return '<process:' + v.id + '>';
		}

		if (v.ctor === '::')
		{
			var output = '[' + toString(v._0);
			v = v._1;
			while (v.ctor === '::')
			{
				output += ',' + toString(v._0);
				v = v._1;
			}
			return output + ']';
		}

		if (v.ctor === '[]')
		{
			return '[]';
		}

		if (v.ctor === 'RBNode_elm_builtin' || v.ctor === 'RBEmpty_elm_builtin' || v.ctor === 'Set_elm_builtin')
		{
			var name, list;
			if (v.ctor === 'Set_elm_builtin')
			{
				name = 'Set';
				list = A2(
					_elm_lang$core$List$map,
					function(x) {return x._0; },
					_elm_lang$core$Dict$toList(v._0)
				);
			}
			else
			{
				name = 'Dict';
				list = _elm_lang$core$Dict$toList(v);
			}
			return name + '.fromList ' + toString(list);
		}

		var output = '';
		for (var i in v)
		{
			if (i === 'ctor') continue;
			var str = toString(v[i]);
			var c0 = str[0];
			var parenless = c0 === '{' || c0 === '(' || c0 === '<' || c0 === '"' || str.indexOf(' ') < 0;
			output += ' ' + (parenless ? str : '(' + str + ')');
		}
		return v.ctor + output;
	}

	if (type === 'object')
	{
		var output = [];
		for (var k in v)
		{
			output.push(k + ' = ' + toString(v[k]));
		}
		if (output.length === 0)
		{
			return '{}';
		}
		return '{ ' + output.join(', ') + ' }';
	}

	return '<internal structure>';
}

function addSlashes(str, isChar)
{
	var s = str.replace(/\\/g, '\\\\')
			  .replace(/\n/g, '\\n')
			  .replace(/\t/g, '\\t')
			  .replace(/\r/g, '\\r')
			  .replace(/\v/g, '\\v')
			  .replace(/\0/g, '\\0');
	if (isChar)
	{
		return s.replace(/\'/g, '\\\'');
	}
	else
	{
		return s.replace(/\"/g, '\\"');
	}
}


return {
	eq: eq,
	cmp: cmp,
	Tuple0: Tuple0,
	Tuple2: Tuple2,
	chr: chr,
	update: update,
	guid: guid,

	append: F2(append),

	crash: crash,
	crashCase: crashCase,

	toString: toString
};

}();var _elm_lang$core$Basics$uncurry = F2(
	function (f, _p0) {
		var _p1 = _p0;
		return A2(f, _p1._0, _p1._1);
	});
var _elm_lang$core$Basics$curry = F3(
	function (f, a, b) {
		return f(
			{ctor: '_Tuple2', _0: a, _1: b});
	});
var _elm_lang$core$Basics$flip = F3(
	function (f, b, a) {
		return A2(f, a, b);
	});
var _elm_lang$core$Basics$snd = function (_p2) {
	var _p3 = _p2;
	return _p3._1;
};
var _elm_lang$core$Basics$fst = function (_p4) {
	var _p5 = _p4;
	return _p5._0;
};
var _elm_lang$core$Basics$always = F2(
	function (a, _p6) {
		return a;
	});
var _elm_lang$core$Basics$identity = function (x) {
	return x;
};
var _elm_lang$core$Basics_ops = _elm_lang$core$Basics_ops || {};
_elm_lang$core$Basics_ops['<|'] = F2(
	function (f, x) {
		return f(x);
	});
var _elm_lang$core$Basics_ops = _elm_lang$core$Basics_ops || {};
_elm_lang$core$Basics_ops['|>'] = F2(
	function (x, f) {
		return f(x);
	});
var _elm_lang$core$Basics_ops = _elm_lang$core$Basics_ops || {};
_elm_lang$core$Basics_ops['>>'] = F3(
	function (f, g, x) {
		return g(
			f(x));
	});
var _elm_lang$core$Basics_ops = _elm_lang$core$Basics_ops || {};
_elm_lang$core$Basics_ops['<<'] = F3(
	function (g, f, x) {
		return g(
			f(x));
	});
var _elm_lang$core$Basics_ops = _elm_lang$core$Basics_ops || {};
_elm_lang$core$Basics_ops['++'] = _elm_lang$core$Native_Utils.append;
var _elm_lang$core$Basics$toString = _elm_lang$core$Native_Utils.toString;
var _elm_lang$core$Basics$isInfinite = _elm_lang$core$Native_Basics.isInfinite;
var _elm_lang$core$Basics$isNaN = _elm_lang$core$Native_Basics.isNaN;
var _elm_lang$core$Basics$toFloat = _elm_lang$core$Native_Basics.toFloat;
var _elm_lang$core$Basics$ceiling = _elm_lang$core$Native_Basics.ceiling;
var _elm_lang$core$Basics$floor = _elm_lang$core$Native_Basics.floor;
var _elm_lang$core$Basics$truncate = _elm_lang$core$Native_Basics.truncate;
var _elm_lang$core$Basics$round = _elm_lang$core$Native_Basics.round;
var _elm_lang$core$Basics$not = _elm_lang$core$Native_Basics.not;
var _elm_lang$core$Basics$xor = _elm_lang$core$Native_Basics.xor;
var _elm_lang$core$Basics_ops = _elm_lang$core$Basics_ops || {};
_elm_lang$core$Basics_ops['||'] = _elm_lang$core$Native_Basics.or;
var _elm_lang$core$Basics_ops = _elm_lang$core$Basics_ops || {};
_elm_lang$core$Basics_ops['&&'] = _elm_lang$core$Native_Basics.and;
var _elm_lang$core$Basics$max = _elm_lang$core$Native_Basics.max;
var _elm_lang$core$Basics$min = _elm_lang$core$Native_Basics.min;
var _elm_lang$core$Basics$compare = _elm_lang$core$Native_Basics.compare;
var _elm_lang$core$Basics_ops = _elm_lang$core$Basics_ops || {};
_elm_lang$core$Basics_ops['>='] = _elm_lang$core$Native_Basics.ge;
var _elm_lang$core$Basics_ops = _elm_lang$core$Basics_ops || {};
_elm_lang$core$Basics_ops['<='] = _elm_lang$core$Native_Basics.le;
var _elm_lang$core$Basics_ops = _elm_lang$core$Basics_ops || {};
_elm_lang$core$Basics_ops['>'] = _elm_lang$core$Native_Basics.gt;
var _elm_lang$core$Basics_ops = _elm_lang$core$Basics_ops || {};
_elm_lang$core$Basics_ops['<'] = _elm_lang$core$Native_Basics.lt;
var _elm_lang$core$Basics_ops = _elm_lang$core$Basics_ops || {};
_elm_lang$core$Basics_ops['/='] = _elm_lang$core$Native_Basics.neq;
var _elm_lang$core$Basics_ops = _elm_lang$core$Basics_ops || {};
_elm_lang$core$Basics_ops['=='] = _elm_lang$core$Native_Basics.eq;
var _elm_lang$core$Basics$e = _elm_lang$core$Native_Basics.e;
var _elm_lang$core$Basics$pi = _elm_lang$core$Native_Basics.pi;
var _elm_lang$core$Basics$clamp = _elm_lang$core$Native_Basics.clamp;
var _elm_lang$core$Basics$logBase = _elm_lang$core$Native_Basics.logBase;
var _elm_lang$core$Basics$abs = _elm_lang$core$Native_Basics.abs;
var _elm_lang$core$Basics$negate = _elm_lang$core$Native_Basics.negate;
var _elm_lang$core$Basics$sqrt = _elm_lang$core$Native_Basics.sqrt;
var _elm_lang$core$Basics$atan2 = _elm_lang$core$Native_Basics.atan2;
var _elm_lang$core$Basics$atan = _elm_lang$core$Native_Basics.atan;
var _elm_lang$core$Basics$asin = _elm_lang$core$Native_Basics.asin;
var _elm_lang$core$Basics$acos = _elm_lang$core$Native_Basics.acos;
var _elm_lang$core$Basics$tan = _elm_lang$core$Native_Basics.tan;
var _elm_lang$core$Basics$sin = _elm_lang$core$Native_Basics.sin;
var _elm_lang$core$Basics$cos = _elm_lang$core$Native_Basics.cos;
var _elm_lang$core$Basics_ops = _elm_lang$core$Basics_ops || {};
_elm_lang$core$Basics_ops['^'] = _elm_lang$core$Native_Basics.exp;
var _elm_lang$core$Basics_ops = _elm_lang$core$Basics_ops || {};
_elm_lang$core$Basics_ops['%'] = _elm_lang$core$Native_Basics.mod;
var _elm_lang$core$Basics$rem = _elm_lang$core$Native_Basics.rem;
var _elm_lang$core$Basics_ops = _elm_lang$core$Basics_ops || {};
_elm_lang$core$Basics_ops['//'] = _elm_lang$core$Native_Basics.div;
var _elm_lang$core$Basics_ops = _elm_lang$core$Basics_ops || {};
_elm_lang$core$Basics_ops['/'] = _elm_lang$core$Native_Basics.floatDiv;
var _elm_lang$core$Basics_ops = _elm_lang$core$Basics_ops || {};
_elm_lang$core$Basics_ops['*'] = _elm_lang$core$Native_Basics.mul;
var _elm_lang$core$Basics_ops = _elm_lang$core$Basics_ops || {};
_elm_lang$core$Basics_ops['-'] = _elm_lang$core$Native_Basics.sub;
var _elm_lang$core$Basics_ops = _elm_lang$core$Basics_ops || {};
_elm_lang$core$Basics_ops['+'] = _elm_lang$core$Native_Basics.add;
var _elm_lang$core$Basics$toPolar = _elm_lang$core$Native_Basics.toPolar;
var _elm_lang$core$Basics$fromPolar = _elm_lang$core$Native_Basics.fromPolar;
var _elm_lang$core$Basics$turns = _elm_lang$core$Native_Basics.turns;
var _elm_lang$core$Basics$degrees = _elm_lang$core$Native_Basics.degrees;
var _elm_lang$core$Basics$radians = function (t) {
	return t;
};
var _elm_lang$core$Basics$GT = {ctor: 'GT'};
var _elm_lang$core$Basics$EQ = {ctor: 'EQ'};
var _elm_lang$core$Basics$LT = {ctor: 'LT'};
var _elm_lang$core$Basics$Never = function (a) {
	return {ctor: 'Never', _0: a};
};
var _elm_lang$core$Maybe$withDefault = F2(
	function ($default, maybe) {
		var _p0 = maybe;
		if (_p0.ctor === 'Just') {
			return _p0._0;
		} else {
			return $default;
		}
	});
var _elm_lang$core$Maybe$Nothing = {ctor: 'Nothing'};
var _elm_lang$core$Maybe$oneOf = function (maybes) {
	oneOf:
	while (true) {
		var _p1 = maybes;
		if (_p1.ctor === '[]') {
			return _elm_lang$core$Maybe$Nothing;
		} else {
			var _p3 = _p1._0;
			var _p2 = _p3;
			if (_p2.ctor === 'Nothing') {
				var _v3 = _p1._1;
				maybes = _v3;
				continue oneOf;
			} else {
				return _p3;
			}
		}
	}
};
var _elm_lang$core$Maybe$andThen = F2(
	function (maybeValue, callback) {
		var _p4 = maybeValue;
		if (_p4.ctor === 'Just') {
			return callback(_p4._0);
		} else {
			return _elm_lang$core$Maybe$Nothing;
		}
	});
var _elm_lang$core$Maybe$Just = function (a) {
	return {ctor: 'Just', _0: a};
};
var _elm_lang$core$Maybe$map = F2(
	function (f, maybe) {
		var _p5 = maybe;
		if (_p5.ctor === 'Just') {
			return _elm_lang$core$Maybe$Just(
				f(_p5._0));
		} else {
			return _elm_lang$core$Maybe$Nothing;
		}
	});
var _elm_lang$core$Maybe$map2 = F3(
	function (func, ma, mb) {
		var _p6 = {ctor: '_Tuple2', _0: ma, _1: mb};
		if (((_p6.ctor === '_Tuple2') && (_p6._0.ctor === 'Just')) && (_p6._1.ctor === 'Just')) {
			return _elm_lang$core$Maybe$Just(
				A2(func, _p6._0._0, _p6._1._0));
		} else {
			return _elm_lang$core$Maybe$Nothing;
		}
	});
var _elm_lang$core$Maybe$map3 = F4(
	function (func, ma, mb, mc) {
		var _p7 = {ctor: '_Tuple3', _0: ma, _1: mb, _2: mc};
		if ((((_p7.ctor === '_Tuple3') && (_p7._0.ctor === 'Just')) && (_p7._1.ctor === 'Just')) && (_p7._2.ctor === 'Just')) {
			return _elm_lang$core$Maybe$Just(
				A3(func, _p7._0._0, _p7._1._0, _p7._2._0));
		} else {
			return _elm_lang$core$Maybe$Nothing;
		}
	});
var _elm_lang$core$Maybe$map4 = F5(
	function (func, ma, mb, mc, md) {
		var _p8 = {ctor: '_Tuple4', _0: ma, _1: mb, _2: mc, _3: md};
		if (((((_p8.ctor === '_Tuple4') && (_p8._0.ctor === 'Just')) && (_p8._1.ctor === 'Just')) && (_p8._2.ctor === 'Just')) && (_p8._3.ctor === 'Just')) {
			return _elm_lang$core$Maybe$Just(
				A4(func, _p8._0._0, _p8._1._0, _p8._2._0, _p8._3._0));
		} else {
			return _elm_lang$core$Maybe$Nothing;
		}
	});
var _elm_lang$core$Maybe$map5 = F6(
	function (func, ma, mb, mc, md, me) {
		var _p9 = {ctor: '_Tuple5', _0: ma, _1: mb, _2: mc, _3: md, _4: me};
		if ((((((_p9.ctor === '_Tuple5') && (_p9._0.ctor === 'Just')) && (_p9._1.ctor === 'Just')) && (_p9._2.ctor === 'Just')) && (_p9._3.ctor === 'Just')) && (_p9._4.ctor === 'Just')) {
			return _elm_lang$core$Maybe$Just(
				A5(func, _p9._0._0, _p9._1._0, _p9._2._0, _p9._3._0, _p9._4._0));
		} else {
			return _elm_lang$core$Maybe$Nothing;
		}
	});
//import Native.Utils //

var _elm_lang$core$Native_List = function() {

var Nil = { ctor: '[]' };

function Cons(hd, tl)
{
	return { ctor: '::', _0: hd, _1: tl };
}

function fromArray(arr)
{
	var out = Nil;
	for (var i = arr.length; i--; )
	{
		out = Cons(arr[i], out);
	}
	return out;
}

function toArray(xs)
{
	var out = [];
	while (xs.ctor !== '[]')
	{
		out.push(xs._0);
		xs = xs._1;
	}
	return out;
}


function range(lo, hi)
{
	var list = Nil;
	if (lo <= hi)
	{
		do
		{
			list = Cons(hi, list);
		}
		while (hi-- > lo);
	}
	return list;
}

function foldr(f, b, xs)
{
	var arr = toArray(xs);
	var acc = b;
	for (var i = arr.length; i--; )
	{
		acc = A2(f, arr[i], acc);
	}
	return acc;
}

function map2(f, xs, ys)
{
	var arr = [];
	while (xs.ctor !== '[]' && ys.ctor !== '[]')
	{
		arr.push(A2(f, xs._0, ys._0));
		xs = xs._1;
		ys = ys._1;
	}
	return fromArray(arr);
}

function map3(f, xs, ys, zs)
{
	var arr = [];
	while (xs.ctor !== '[]' && ys.ctor !== '[]' && zs.ctor !== '[]')
	{
		arr.push(A3(f, xs._0, ys._0, zs._0));
		xs = xs._1;
		ys = ys._1;
		zs = zs._1;
	}
	return fromArray(arr);
}

function map4(f, ws, xs, ys, zs)
{
	var arr = [];
	while (   ws.ctor !== '[]'
		   && xs.ctor !== '[]'
		   && ys.ctor !== '[]'
		   && zs.ctor !== '[]')
	{
		arr.push(A4(f, ws._0, xs._0, ys._0, zs._0));
		ws = ws._1;
		xs = xs._1;
		ys = ys._1;
		zs = zs._1;
	}
	return fromArray(arr);
}

function map5(f, vs, ws, xs, ys, zs)
{
	var arr = [];
	while (   vs.ctor !== '[]'
		   && ws.ctor !== '[]'
		   && xs.ctor !== '[]'
		   && ys.ctor !== '[]'
		   && zs.ctor !== '[]')
	{
		arr.push(A5(f, vs._0, ws._0, xs._0, ys._0, zs._0));
		vs = vs._1;
		ws = ws._1;
		xs = xs._1;
		ys = ys._1;
		zs = zs._1;
	}
	return fromArray(arr);
}

function sortBy(f, xs)
{
	return fromArray(toArray(xs).sort(function(a, b) {
		return _elm_lang$core$Native_Utils.cmp(f(a), f(b));
	}));
}

function sortWith(f, xs)
{
	return fromArray(toArray(xs).sort(function(a, b) {
		var ord = f(a)(b).ctor;
		return ord === 'EQ' ? 0 : ord === 'LT' ? -1 : 1;
	}));
}

return {
	Nil: Nil,
	Cons: Cons,
	cons: F2(Cons),
	toArray: toArray,
	fromArray: fromArray,
	range: range,

	foldr: F3(foldr),

	map2: F3(map2),
	map3: F4(map3),
	map4: F5(map4),
	map5: F6(map5),
	sortBy: F2(sortBy),
	sortWith: F2(sortWith)
};

}();var _elm_lang$core$List$sortWith = _elm_lang$core$Native_List.sortWith;
var _elm_lang$core$List$sortBy = _elm_lang$core$Native_List.sortBy;
var _elm_lang$core$List$sort = function (xs) {
	return A2(_elm_lang$core$List$sortBy, _elm_lang$core$Basics$identity, xs);
};
var _elm_lang$core$List$drop = F2(
	function (n, list) {
		drop:
		while (true) {
			if (_elm_lang$core$Native_Utils.cmp(n, 0) < 1) {
				return list;
			} else {
				var _p0 = list;
				if (_p0.ctor === '[]') {
					return list;
				} else {
					var _v1 = n - 1,
						_v2 = _p0._1;
					n = _v1;
					list = _v2;
					continue drop;
				}
			}
		}
	});
var _elm_lang$core$List$map5 = _elm_lang$core$Native_List.map5;
var _elm_lang$core$List$map4 = _elm_lang$core$Native_List.map4;
var _elm_lang$core$List$map3 = _elm_lang$core$Native_List.map3;
var _elm_lang$core$List$map2 = _elm_lang$core$Native_List.map2;
var _elm_lang$core$List$any = F2(
	function (isOkay, list) {
		any:
		while (true) {
			var _p1 = list;
			if (_p1.ctor === '[]') {
				return false;
			} else {
				if (isOkay(_p1._0)) {
					return true;
				} else {
					var _v4 = isOkay,
						_v5 = _p1._1;
					isOkay = _v4;
					list = _v5;
					continue any;
				}
			}
		}
	});
var _elm_lang$core$List$all = F2(
	function (isOkay, list) {
		return _elm_lang$core$Basics$not(
			A2(
				_elm_lang$core$List$any,
				function (_p2) {
					return _elm_lang$core$Basics$not(
						isOkay(_p2));
				},
				list));
	});
var _elm_lang$core$List$foldr = _elm_lang$core$Native_List.foldr;
var _elm_lang$core$List$foldl = F3(
	function (func, acc, list) {
		foldl:
		while (true) {
			var _p3 = list;
			if (_p3.ctor === '[]') {
				return acc;
			} else {
				var _v7 = func,
					_v8 = A2(func, _p3._0, acc),
					_v9 = _p3._1;
				func = _v7;
				acc = _v8;
				list = _v9;
				continue foldl;
			}
		}
	});
var _elm_lang$core$List$length = function (xs) {
	return A3(
		_elm_lang$core$List$foldl,
		F2(
			function (_p4, i) {
				return i + 1;
			}),
		0,
		xs);
};
var _elm_lang$core$List$sum = function (numbers) {
	return A3(
		_elm_lang$core$List$foldl,
		F2(
			function (x, y) {
				return x + y;
			}),
		0,
		numbers);
};
var _elm_lang$core$List$product = function (numbers) {
	return A3(
		_elm_lang$core$List$foldl,
		F2(
			function (x, y) {
				return x * y;
			}),
		1,
		numbers);
};
var _elm_lang$core$List$maximum = function (list) {
	var _p5 = list;
	if (_p5.ctor === '::') {
		return _elm_lang$core$Maybe$Just(
			A3(_elm_lang$core$List$foldl, _elm_lang$core$Basics$max, _p5._0, _p5._1));
	} else {
		return _elm_lang$core$Maybe$Nothing;
	}
};
var _elm_lang$core$List$minimum = function (list) {
	var _p6 = list;
	if (_p6.ctor === '::') {
		return _elm_lang$core$Maybe$Just(
			A3(_elm_lang$core$List$foldl, _elm_lang$core$Basics$min, _p6._0, _p6._1));
	} else {
		return _elm_lang$core$Maybe$Nothing;
	}
};
var _elm_lang$core$List$indexedMap = F2(
	function (f, xs) {
		return A3(
			_elm_lang$core$List$map2,
			f,
			_elm_lang$core$Native_List.range(
				0,
				_elm_lang$core$List$length(xs) - 1),
			xs);
	});
var _elm_lang$core$List$member = F2(
	function (x, xs) {
		return A2(
			_elm_lang$core$List$any,
			function (a) {
				return _elm_lang$core$Native_Utils.eq(a, x);
			},
			xs);
	});
var _elm_lang$core$List$isEmpty = function (xs) {
	var _p7 = xs;
	if (_p7.ctor === '[]') {
		return true;
	} else {
		return false;
	}
};
var _elm_lang$core$List$tail = function (list) {
	var _p8 = list;
	if (_p8.ctor === '::') {
		return _elm_lang$core$Maybe$Just(_p8._1);
	} else {
		return _elm_lang$core$Maybe$Nothing;
	}
};
var _elm_lang$core$List$head = function (list) {
	var _p9 = list;
	if (_p9.ctor === '::') {
		return _elm_lang$core$Maybe$Just(_p9._0);
	} else {
		return _elm_lang$core$Maybe$Nothing;
	}
};
var _elm_lang$core$List_ops = _elm_lang$core$List_ops || {};
_elm_lang$core$List_ops['::'] = _elm_lang$core$Native_List.cons;
var _elm_lang$core$List$map = F2(
	function (f, xs) {
		return A3(
			_elm_lang$core$List$foldr,
			F2(
				function (x, acc) {
					return A2(
						_elm_lang$core$List_ops['::'],
						f(x),
						acc);
				}),
			_elm_lang$core$Native_List.fromArray(
				[]),
			xs);
	});
var _elm_lang$core$List$filter = F2(
	function (pred, xs) {
		var conditionalCons = F2(
			function (x, xs$) {
				return pred(x) ? A2(_elm_lang$core$List_ops['::'], x, xs$) : xs$;
			});
		return A3(
			_elm_lang$core$List$foldr,
			conditionalCons,
			_elm_lang$core$Native_List.fromArray(
				[]),
			xs);
	});
var _elm_lang$core$List$maybeCons = F3(
	function (f, mx, xs) {
		var _p10 = f(mx);
		if (_p10.ctor === 'Just') {
			return A2(_elm_lang$core$List_ops['::'], _p10._0, xs);
		} else {
			return xs;
		}
	});
var _elm_lang$core$List$filterMap = F2(
	function (f, xs) {
		return A3(
			_elm_lang$core$List$foldr,
			_elm_lang$core$List$maybeCons(f),
			_elm_lang$core$Native_List.fromArray(
				[]),
			xs);
	});
var _elm_lang$core$List$reverse = function (list) {
	return A3(
		_elm_lang$core$List$foldl,
		F2(
			function (x, y) {
				return A2(_elm_lang$core$List_ops['::'], x, y);
			}),
		_elm_lang$core$Native_List.fromArray(
			[]),
		list);
};
var _elm_lang$core$List$scanl = F3(
	function (f, b, xs) {
		var scan1 = F2(
			function (x, accAcc) {
				var _p11 = accAcc;
				if (_p11.ctor === '::') {
					return A2(
						_elm_lang$core$List_ops['::'],
						A2(f, x, _p11._0),
						accAcc);
				} else {
					return _elm_lang$core$Native_List.fromArray(
						[]);
				}
			});
		return _elm_lang$core$List$reverse(
			A3(
				_elm_lang$core$List$foldl,
				scan1,
				_elm_lang$core$Native_List.fromArray(
					[b]),
				xs));
	});
var _elm_lang$core$List$append = F2(
	function (xs, ys) {
		var _p12 = ys;
		if (_p12.ctor === '[]') {
			return xs;
		} else {
			return A3(
				_elm_lang$core$List$foldr,
				F2(
					function (x, y) {
						return A2(_elm_lang$core$List_ops['::'], x, y);
					}),
				ys,
				xs);
		}
	});
var _elm_lang$core$List$concat = function (lists) {
	return A3(
		_elm_lang$core$List$foldr,
		_elm_lang$core$List$append,
		_elm_lang$core$Native_List.fromArray(
			[]),
		lists);
};
var _elm_lang$core$List$concatMap = F2(
	function (f, list) {
		return _elm_lang$core$List$concat(
			A2(_elm_lang$core$List$map, f, list));
	});
var _elm_lang$core$List$partition = F2(
	function (pred, list) {
		var step = F2(
			function (x, _p13) {
				var _p14 = _p13;
				var _p16 = _p14._0;
				var _p15 = _p14._1;
				return pred(x) ? {
					ctor: '_Tuple2',
					_0: A2(_elm_lang$core$List_ops['::'], x, _p16),
					_1: _p15
				} : {
					ctor: '_Tuple2',
					_0: _p16,
					_1: A2(_elm_lang$core$List_ops['::'], x, _p15)
				};
			});
		return A3(
			_elm_lang$core$List$foldr,
			step,
			{
				ctor: '_Tuple2',
				_0: _elm_lang$core$Native_List.fromArray(
					[]),
				_1: _elm_lang$core$Native_List.fromArray(
					[])
			},
			list);
	});
var _elm_lang$core$List$unzip = function (pairs) {
	var step = F2(
		function (_p18, _p17) {
			var _p19 = _p18;
			var _p20 = _p17;
			return {
				ctor: '_Tuple2',
				_0: A2(_elm_lang$core$List_ops['::'], _p19._0, _p20._0),
				_1: A2(_elm_lang$core$List_ops['::'], _p19._1, _p20._1)
			};
		});
	return A3(
		_elm_lang$core$List$foldr,
		step,
		{
			ctor: '_Tuple2',
			_0: _elm_lang$core$Native_List.fromArray(
				[]),
			_1: _elm_lang$core$Native_List.fromArray(
				[])
		},
		pairs);
};
var _elm_lang$core$List$intersperse = F2(
	function (sep, xs) {
		var _p21 = xs;
		if (_p21.ctor === '[]') {
			return _elm_lang$core$Native_List.fromArray(
				[]);
		} else {
			var step = F2(
				function (x, rest) {
					return A2(
						_elm_lang$core$List_ops['::'],
						sep,
						A2(_elm_lang$core$List_ops['::'], x, rest));
				});
			var spersed = A3(
				_elm_lang$core$List$foldr,
				step,
				_elm_lang$core$Native_List.fromArray(
					[]),
				_p21._1);
			return A2(_elm_lang$core$List_ops['::'], _p21._0, spersed);
		}
	});
var _elm_lang$core$List$take = F2(
	function (n, list) {
		if (_elm_lang$core$Native_Utils.cmp(n, 0) < 1) {
			return _elm_lang$core$Native_List.fromArray(
				[]);
		} else {
			var _p22 = list;
			if (_p22.ctor === '[]') {
				return list;
			} else {
				return A2(
					_elm_lang$core$List_ops['::'],
					_p22._0,
					A2(_elm_lang$core$List$take, n - 1, _p22._1));
			}
		}
	});
var _elm_lang$core$List$repeatHelp = F3(
	function (result, n, value) {
		repeatHelp:
		while (true) {
			if (_elm_lang$core$Native_Utils.cmp(n, 0) < 1) {
				return result;
			} else {
				var _v23 = A2(_elm_lang$core$List_ops['::'], value, result),
					_v24 = n - 1,
					_v25 = value;
				result = _v23;
				n = _v24;
				value = _v25;
				continue repeatHelp;
			}
		}
	});
var _elm_lang$core$List$repeat = F2(
	function (n, value) {
		return A3(
			_elm_lang$core$List$repeatHelp,
			_elm_lang$core$Native_List.fromArray(
				[]),
			n,
			value);
	});
//import Native.Utils //

var _elm_lang$core$Native_Scheduler = function() {

var MAX_STEPS = 10000;


// TASKS

function succeed(value)
{
	return {
		ctor: '_Task_succeed',
		value: value
	};
}

function fail(error)
{
	return {
		ctor: '_Task_fail',
		value: error
	};
}

function nativeBinding(callback)
{
	return {
		ctor: '_Task_nativeBinding',
		callback: callback,
		cancel: null
	};
}

function andThen(task, callback)
{
	return {
		ctor: '_Task_andThen',
		task: task,
		callback: callback
	};
}

function onError(task, callback)
{
	return {
		ctor: '_Task_onError',
		task: task,
		callback: callback
	};
}

function receive(callback)
{
	return {
		ctor: '_Task_receive',
		callback: callback
	};
}


// PROCESSES

function rawSpawn(task)
{
	var process = {
		ctor: '_Process',
		id: _elm_lang$core$Native_Utils.guid(),
		root: task,
		stack: null,
		mailbox: []
	};

	enqueue(process);

	return process;
}

function spawn(task)
{
	return nativeBinding(function(callback) {
		var process = rawSpawn(task);
		callback(succeed(process));
	});
}

function rawSend(process, msg)
{
	process.mailbox.push(msg);
	enqueue(process);
}

function send(process, msg)
{
	return nativeBinding(function(callback) {
		rawSend(process, msg);
		callback(succeed(_elm_lang$core$Native_Utils.Tuple0));
	});
}

function kill(process)
{
	return nativeBinding(function(callback) {
		var root = process.root;
		if (root.ctor === '_Task_nativeBinding' && root.cancel)
		{
			root.cancel();
		}

		process.root = null;

		callback(succeed(_elm_lang$core$Native_Utils.Tuple0));
	});
}

function sleep(time)
{
	return nativeBinding(function(callback) {
		var id = setTimeout(function() {
			callback(succeed(_elm_lang$core$Native_Utils.Tuple0));
		}, time);

		return function() { clearTimeout(id); };
	});
}


// STEP PROCESSES

function step(numSteps, process)
{
	while (numSteps < MAX_STEPS)
	{
		var ctor = process.root.ctor;

		if (ctor === '_Task_succeed')
		{
			while (process.stack && process.stack.ctor === '_Task_onError')
			{
				process.stack = process.stack.rest;
			}
			if (process.stack === null)
			{
				break;
			}
			process.root = process.stack.callback(process.root.value);
			process.stack = process.stack.rest;
			++numSteps;
			continue;
		}

		if (ctor === '_Task_fail')
		{
			while (process.stack && process.stack.ctor === '_Task_andThen')
			{
				process.stack = process.stack.rest;
			}
			if (process.stack === null)
			{
				break;
			}
			process.root = process.stack.callback(process.root.value);
			process.stack = process.stack.rest;
			++numSteps;
			continue;
		}

		if (ctor === '_Task_andThen')
		{
			process.stack = {
				ctor: '_Task_andThen',
				callback: process.root.callback,
				rest: process.stack
			};
			process.root = process.root.task;
			++numSteps;
			continue;
		}

		if (ctor === '_Task_onError')
		{
			process.stack = {
				ctor: '_Task_onError',
				callback: process.root.callback,
				rest: process.stack
			};
			process.root = process.root.task;
			++numSteps;
			continue;
		}

		if (ctor === '_Task_nativeBinding')
		{
			process.root.cancel = process.root.callback(function(newRoot) {
				process.root = newRoot;
				enqueue(process);
			});

			break;
		}

		if (ctor === '_Task_receive')
		{
			var mailbox = process.mailbox;
			if (mailbox.length === 0)
			{
				break;
			}

			process.root = process.root.callback(mailbox.shift());
			++numSteps;
			continue;
		}

		throw new Error(ctor);
	}

	if (numSteps < MAX_STEPS)
	{
		return numSteps + 1;
	}
	enqueue(process);

	return numSteps;
}


// WORK QUEUE

var working = false;
var workQueue = [];

function enqueue(process)
{
	workQueue.push(process);

	if (!working)
	{
		setTimeout(work, 0);
		working = true;
	}
}

function work()
{
	var numSteps = 0;
	var process;
	while (numSteps < MAX_STEPS && (process = workQueue.shift()))
	{
		numSteps = step(numSteps, process);
	}
	if (!process)
	{
		working = false;
		return;
	}
	setTimeout(work, 0);
}


return {
	succeed: succeed,
	fail: fail,
	nativeBinding: nativeBinding,
	andThen: F2(andThen),
	onError: F2(onError),
	receive: receive,

	spawn: spawn,
	kill: kill,
	sleep: sleep,
	send: F2(send),

	rawSpawn: rawSpawn,
	rawSend: rawSend
};

}();//import //

var _elm_lang$core$Native_Platform = function() {


// PROGRAMS

function addPublicModule(object, name, main)
{
	var init = main ? makeEmbed(name, main) : mainIsUndefined(name);

	object['worker'] = function worker(flags)
	{
		return init(undefined, flags, false);
	}

	object['embed'] = function embed(domNode, flags)
	{
		return init(domNode, flags, true);
	}

	object['fullscreen'] = function fullscreen(flags)
	{
		return init(document.body, flags, true);
	};
}


// PROGRAM FAIL

function mainIsUndefined(name)
{
	return function(domNode)
	{
		var message = 'Cannot initialize module `' + name +
			'` because it has no `main` value!\nWhat should I show on screen?';
		domNode.innerHTML = errorHtml(message);
		throw new Error(message);
	};
}

function errorHtml(message)
{
	return '<div style="padding-left:1em;">'
		+ '<h2 style="font-weight:normal;"><b>Oops!</b> Something went wrong when starting your Elm program.</h2>'
		+ '<pre style="padding-left:1em;">' + message + '</pre>'
		+ '</div>';
}


// PROGRAM SUCCESS

function makeEmbed(moduleName, main)
{
	return function embed(rootDomNode, flags, withRenderer)
	{
		try
		{
			var program = mainToProgram(moduleName, main);
			if (!withRenderer)
			{
				program.renderer = dummyRenderer;
			}
			return makeEmbedHelp(moduleName, program, rootDomNode, flags);
		}
		catch (e)
		{
			rootDomNode.innerHTML = errorHtml(e.message);
			throw e;
		}
	};
}

function dummyRenderer()
{
	return { update: function() {} };
}


// MAIN TO PROGRAM

function mainToProgram(moduleName, wrappedMain)
{
	var main = wrappedMain.main;

	if (typeof main.init === 'undefined')
	{
		var emptyBag = batch(_elm_lang$core$Native_List.Nil);
		var noChange = _elm_lang$core$Native_Utils.Tuple2(
			_elm_lang$core$Native_Utils.Tuple0,
			emptyBag
		);

		return _elm_lang$virtual_dom$VirtualDom$programWithFlags({
			init: function() { return noChange; },
			view: function() { return main; },
			update: F2(function() { return noChange; }),
			subscriptions: function () { return emptyBag; }
		});
	}

	var flags = wrappedMain.flags;
	var init = flags
		? initWithFlags(moduleName, main.init, flags)
		: initWithoutFlags(moduleName, main.init);

	return _elm_lang$virtual_dom$VirtualDom$programWithFlags({
		init: init,
		view: main.view,
		update: main.update,
		subscriptions: main.subscriptions,
	});
}

function initWithoutFlags(moduleName, realInit)
{
	return function init(flags)
	{
		if (typeof flags !== 'undefined')
		{
			throw new Error(
				'You are giving module `' + moduleName + '` an argument in JavaScript.\n'
				+ 'This module does not take arguments though! You probably need to change the\n'
				+ 'initialization code to something like `Elm.' + moduleName + '.fullscreen()`'
			);
		}
		return realInit();
	};
}

function initWithFlags(moduleName, realInit, flagDecoder)
{
	return function init(flags)
	{
		var result = A2(_elm_lang$core$Native_Json.run, flagDecoder, flags);
		if (result.ctor === 'Err')
		{
			throw new Error(
				'You are trying to initialize module `' + moduleName + '` with an unexpected argument.\n'
				+ 'When trying to convert it to a usable Elm value, I run into this problem:\n\n'
				+ result._0
			);
		}
		return realInit(result._0);
	};
}


// SETUP RUNTIME SYSTEM

function makeEmbedHelp(moduleName, program, rootDomNode, flags)
{
	var init = program.init;
	var update = program.update;
	var subscriptions = program.subscriptions;
	var view = program.view;
	var makeRenderer = program.renderer;

	// ambient state
	var managers = {};
	var renderer;

	// init and update state in main process
	var initApp = _elm_lang$core$Native_Scheduler.nativeBinding(function(callback) {
		var results = init(flags);
		var model = results._0;
		renderer = makeRenderer(rootDomNode, enqueue, view(model));
		var cmds = results._1;
		var subs = subscriptions(model);
		dispatchEffects(managers, cmds, subs);
		callback(_elm_lang$core$Native_Scheduler.succeed(model));
	});

	function onMessage(msg, model)
	{
		return _elm_lang$core$Native_Scheduler.nativeBinding(function(callback) {
			var results = A2(update, msg, model);
			model = results._0;
			renderer.update(view(model));
			var cmds = results._1;
			var subs = subscriptions(model);
			dispatchEffects(managers, cmds, subs);
			callback(_elm_lang$core$Native_Scheduler.succeed(model));
		});
	}

	var mainProcess = spawnLoop(initApp, onMessage);

	function enqueue(msg)
	{
		_elm_lang$core$Native_Scheduler.rawSend(mainProcess, msg);
	}

	var ports = setupEffects(managers, enqueue);

	return ports ? { ports: ports } : {};
}


// EFFECT MANAGERS

var effectManagers = {};

function setupEffects(managers, callback)
{
	var ports;

	// setup all necessary effect managers
	for (var key in effectManagers)
	{
		var manager = effectManagers[key];

		if (manager.isForeign)
		{
			ports = ports || {};
			ports[key] = manager.tag === 'cmd'
				? setupOutgoingPort(key)
				: setupIncomingPort(key, callback);
		}

		managers[key] = makeManager(manager, callback);
	}

	return ports;
}

function makeManager(info, callback)
{
	var router = {
		main: callback,
		self: undefined
	};

	var tag = info.tag;
	var onEffects = info.onEffects;
	var onSelfMsg = info.onSelfMsg;

	function onMessage(msg, state)
	{
		if (msg.ctor === 'self')
		{
			return A3(onSelfMsg, router, msg._0, state);
		}

		var fx = msg._0;
		switch (tag)
		{
			case 'cmd':
				return A3(onEffects, router, fx.cmds, state);

			case 'sub':
				return A3(onEffects, router, fx.subs, state);

			case 'fx':
				return A4(onEffects, router, fx.cmds, fx.subs, state);
		}
	}

	var process = spawnLoop(info.init, onMessage);
	router.self = process;
	return process;
}

function sendToApp(router, msg)
{
	return _elm_lang$core$Native_Scheduler.nativeBinding(function(callback)
	{
		router.main(msg);
		callback(_elm_lang$core$Native_Scheduler.succeed(_elm_lang$core$Native_Utils.Tuple0));
	});
}

function sendToSelf(router, msg)
{
	return A2(_elm_lang$core$Native_Scheduler.send, router.self, {
		ctor: 'self',
		_0: msg
	});
}


// HELPER for STATEFUL LOOPS

function spawnLoop(init, onMessage)
{
	var andThen = _elm_lang$core$Native_Scheduler.andThen;

	function loop(state)
	{
		var handleMsg = _elm_lang$core$Native_Scheduler.receive(function(msg) {
			return onMessage(msg, state);
		});
		return A2(andThen, handleMsg, loop);
	}

	var task = A2(andThen, init, loop);

	return _elm_lang$core$Native_Scheduler.rawSpawn(task);
}


// BAGS

function leaf(home)
{
	return function(value)
	{
		return {
			type: 'leaf',
			home: home,
			value: value
		};
	};
}

function batch(list)
{
	return {
		type: 'node',
		branches: list
	};
}

function map(tagger, bag)
{
	return {
		type: 'map',
		tagger: tagger,
		tree: bag
	}
}


// PIPE BAGS INTO EFFECT MANAGERS

function dispatchEffects(managers, cmdBag, subBag)
{
	var effectsDict = {};
	gatherEffects(true, cmdBag, effectsDict, null);
	gatherEffects(false, subBag, effectsDict, null);

	for (var home in managers)
	{
		var fx = home in effectsDict
			? effectsDict[home]
			: {
				cmds: _elm_lang$core$Native_List.Nil,
				subs: _elm_lang$core$Native_List.Nil
			};

		_elm_lang$core$Native_Scheduler.rawSend(managers[home], { ctor: 'fx', _0: fx });
	}
}

function gatherEffects(isCmd, bag, effectsDict, taggers)
{
	switch (bag.type)
	{
		case 'leaf':
			var home = bag.home;
			var effect = toEffect(isCmd, home, taggers, bag.value);
			effectsDict[home] = insert(isCmd, effect, effectsDict[home]);
			return;

		case 'node':
			var list = bag.branches;
			while (list.ctor !== '[]')
			{
				gatherEffects(isCmd, list._0, effectsDict, taggers);
				list = list._1;
			}
			return;

		case 'map':
			gatherEffects(isCmd, bag.tree, effectsDict, {
				tagger: bag.tagger,
				rest: taggers
			});
			return;
	}
}

function toEffect(isCmd, home, taggers, value)
{
	function applyTaggers(x)
	{
		var temp = taggers;
		while (temp)
		{
			x = temp.tagger(x);
			temp = temp.rest;
		}
		return x;
	}

	var map = isCmd
		? effectManagers[home].cmdMap
		: effectManagers[home].subMap;

	return A2(map, applyTaggers, value)
}

function insert(isCmd, newEffect, effects)
{
	effects = effects || {
		cmds: _elm_lang$core$Native_List.Nil,
		subs: _elm_lang$core$Native_List.Nil
	};
	if (isCmd)
	{
		effects.cmds = _elm_lang$core$Native_List.Cons(newEffect, effects.cmds);
		return effects;
	}
	effects.subs = _elm_lang$core$Native_List.Cons(newEffect, effects.subs);
	return effects;
}


// PORTS

function checkPortName(name)
{
	if (name in effectManagers)
	{
		throw new Error('There can only be one port named `' + name + '`, but your program has multiple.');
	}
}


// OUTGOING PORTS

function outgoingPort(name, converter)
{
	checkPortName(name);
	effectManagers[name] = {
		tag: 'cmd',
		cmdMap: outgoingPortMap,
		converter: converter,
		isForeign: true
	};
	return leaf(name);
}

var outgoingPortMap = F2(function cmdMap(tagger, value) {
	return value;
});

function setupOutgoingPort(name)
{
	var subs = [];
	var converter = effectManagers[name].converter;

	// CREATE MANAGER

	var init = _elm_lang$core$Native_Scheduler.succeed(null);

	function onEffects(router, cmdList, state)
	{
		while (cmdList.ctor !== '[]')
		{
			var value = converter(cmdList._0);
			for (var i = 0; i < subs.length; i++)
			{
				subs[i](value);
			}
			cmdList = cmdList._1;
		}
		return init;
	}

	effectManagers[name].init = init;
	effectManagers[name].onEffects = F3(onEffects);

	// PUBLIC API

	function subscribe(callback)
	{
		subs.push(callback);
	}

	function unsubscribe(callback)
	{
		var index = subs.indexOf(callback);
		if (index >= 0)
		{
			subs.splice(index, 1);
		}
	}

	return {
		subscribe: subscribe,
		unsubscribe: unsubscribe
	};
}


// INCOMING PORTS

function incomingPort(name, converter)
{
	checkPortName(name);
	effectManagers[name] = {
		tag: 'sub',
		subMap: incomingPortMap,
		converter: converter,
		isForeign: true
	};
	return leaf(name);
}

var incomingPortMap = F2(function subMap(tagger, finalTagger)
{
	return function(value)
	{
		return tagger(finalTagger(value));
	};
});

function setupIncomingPort(name, callback)
{
	var subs = _elm_lang$core$Native_List.Nil;
	var converter = effectManagers[name].converter;

	// CREATE MANAGER

	var init = _elm_lang$core$Native_Scheduler.succeed(null);

	function onEffects(router, subList, state)
	{
		subs = subList;
		return init;
	}

	effectManagers[name].init = init;
	effectManagers[name].onEffects = F3(onEffects);

	// PUBLIC API

	function send(value)
	{
		var result = A2(_elm_lang$core$Json_Decode$decodeValue, converter, value);
		if (result.ctor === 'Err')
		{
			throw new Error('Trying to send an unexpected type of value through port `' + name + '`:\n' + result._0);
		}

		var value = result._0;
		var temp = subs;
		while (temp.ctor !== '[]')
		{
			callback(temp._0(value));
			temp = temp._1;
		}
	}

	return { send: send };
}

return {
	// routers
	sendToApp: F2(sendToApp),
	sendToSelf: F2(sendToSelf),

	// global setup
	mainToProgram: mainToProgram,
	effectManagers: effectManagers,
	outgoingPort: outgoingPort,
	incomingPort: incomingPort,
	addPublicModule: addPublicModule,

	// effect bags
	leaf: leaf,
	batch: batch,
	map: F2(map)
};

}();var _elm_lang$core$Platform$hack = _elm_lang$core$Native_Scheduler.succeed;
var _elm_lang$core$Platform$sendToSelf = _elm_lang$core$Native_Platform.sendToSelf;
var _elm_lang$core$Platform$sendToApp = _elm_lang$core$Native_Platform.sendToApp;
var _elm_lang$core$Platform$Program = {ctor: 'Program'};
var _elm_lang$core$Platform$Task = {ctor: 'Task'};
var _elm_lang$core$Platform$ProcessId = {ctor: 'ProcessId'};
var _elm_lang$core$Platform$Router = {ctor: 'Router'};
var _elm_lang$core$Platform_Cmd$batch = _elm_lang$core$Native_Platform.batch;
var _elm_lang$core$Platform_Cmd$none = _elm_lang$core$Platform_Cmd$batch(
	_elm_lang$core$Native_List.fromArray(
		[]));
var _elm_lang$core$Platform_Cmd_ops = _elm_lang$core$Platform_Cmd_ops || {};
_elm_lang$core$Platform_Cmd_ops['!'] = F2(
	function (model, commands) {
		return {
			ctor: '_Tuple2',
			_0: model,
			_1: _elm_lang$core$Platform_Cmd$batch(commands)
		};
	});
var _elm_lang$core$Platform_Cmd$map = _elm_lang$core$Native_Platform.map;
var _elm_lang$core$Platform_Cmd$Cmd = {ctor: 'Cmd'};
var _elm_lang$core$Result$toMaybe = function (result) {
	var _p0 = result;
	if (_p0.ctor === 'Ok') {
		return _elm_lang$core$Maybe$Just(_p0._0);
	} else {
		return _elm_lang$core$Maybe$Nothing;
	}
};
var _elm_lang$core$Result$withDefault = F2(
	function (def, result) {
		var _p1 = result;
		if (_p1.ctor === 'Ok') {
			return _p1._0;
		} else {
			return def;
		}
	});
var _elm_lang$core$Result$Err = function (a) {
	return {ctor: 'Err', _0: a};
};
var _elm_lang$core$Result$andThen = F2(
	function (result, callback) {
		var _p2 = result;
		if (_p2.ctor === 'Ok') {
			return callback(_p2._0);
		} else {
			return _elm_lang$core$Result$Err(_p2._0);
		}
	});
var _elm_lang$core$Result$Ok = function (a) {
	return {ctor: 'Ok', _0: a};
};
var _elm_lang$core$Result$map = F2(
	function (func, ra) {
		var _p3 = ra;
		if (_p3.ctor === 'Ok') {
			return _elm_lang$core$Result$Ok(
				func(_p3._0));
		} else {
			return _elm_lang$core$Result$Err(_p3._0);
		}
	});
var _elm_lang$core$Result$map2 = F3(
	function (func, ra, rb) {
		var _p4 = {ctor: '_Tuple2', _0: ra, _1: rb};
		if (_p4._0.ctor === 'Ok') {
			if (_p4._1.ctor === 'Ok') {
				return _elm_lang$core$Result$Ok(
					A2(func, _p4._0._0, _p4._1._0));
			} else {
				return _elm_lang$core$Result$Err(_p4._1._0);
			}
		} else {
			return _elm_lang$core$Result$Err(_p4._0._0);
		}
	});
var _elm_lang$core$Result$map3 = F4(
	function (func, ra, rb, rc) {
		var _p5 = {ctor: '_Tuple3', _0: ra, _1: rb, _2: rc};
		if (_p5._0.ctor === 'Ok') {
			if (_p5._1.ctor === 'Ok') {
				if (_p5._2.ctor === 'Ok') {
					return _elm_lang$core$Result$Ok(
						A3(func, _p5._0._0, _p5._1._0, _p5._2._0));
				} else {
					return _elm_lang$core$Result$Err(_p5._2._0);
				}
			} else {
				return _elm_lang$core$Result$Err(_p5._1._0);
			}
		} else {
			return _elm_lang$core$Result$Err(_p5._0._0);
		}
	});
var _elm_lang$core$Result$map4 = F5(
	function (func, ra, rb, rc, rd) {
		var _p6 = {ctor: '_Tuple4', _0: ra, _1: rb, _2: rc, _3: rd};
		if (_p6._0.ctor === 'Ok') {
			if (_p6._1.ctor === 'Ok') {
				if (_p6._2.ctor === 'Ok') {
					if (_p6._3.ctor === 'Ok') {
						return _elm_lang$core$Result$Ok(
							A4(func, _p6._0._0, _p6._1._0, _p6._2._0, _p6._3._0));
					} else {
						return _elm_lang$core$Result$Err(_p6._3._0);
					}
				} else {
					return _elm_lang$core$Result$Err(_p6._2._0);
				}
			} else {
				return _elm_lang$core$Result$Err(_p6._1._0);
			}
		} else {
			return _elm_lang$core$Result$Err(_p6._0._0);
		}
	});
var _elm_lang$core$Result$map5 = F6(
	function (func, ra, rb, rc, rd, re) {
		var _p7 = {ctor: '_Tuple5', _0: ra, _1: rb, _2: rc, _3: rd, _4: re};
		if (_p7._0.ctor === 'Ok') {
			if (_p7._1.ctor === 'Ok') {
				if (_p7._2.ctor === 'Ok') {
					if (_p7._3.ctor === 'Ok') {
						if (_p7._4.ctor === 'Ok') {
							return _elm_lang$core$Result$Ok(
								A5(func, _p7._0._0, _p7._1._0, _p7._2._0, _p7._3._0, _p7._4._0));
						} else {
							return _elm_lang$core$Result$Err(_p7._4._0);
						}
					} else {
						return _elm_lang$core$Result$Err(_p7._3._0);
					}
				} else {
					return _elm_lang$core$Result$Err(_p7._2._0);
				}
			} else {
				return _elm_lang$core$Result$Err(_p7._1._0);
			}
		} else {
			return _elm_lang$core$Result$Err(_p7._0._0);
		}
	});
var _elm_lang$core$Result$formatError = F2(
	function (f, result) {
		var _p8 = result;
		if (_p8.ctor === 'Ok') {
			return _elm_lang$core$Result$Ok(_p8._0);
		} else {
			return _elm_lang$core$Result$Err(
				f(_p8._0));
		}
	});
var _elm_lang$core$Result$fromMaybe = F2(
	function (err, maybe) {
		var _p9 = maybe;
		if (_p9.ctor === 'Just') {
			return _elm_lang$core$Result$Ok(_p9._0);
		} else {
			return _elm_lang$core$Result$Err(err);
		}
	});
//import Native.Utils //

var _elm_lang$core$Native_Debug = function() {

function log(tag, value)
{
	var msg = tag + ': ' + _elm_lang$core$Native_Utils.toString(value);
	var process = process || {};
	if (process.stdout)
	{
		process.stdout.write(msg);
	}
	else
	{
		console.log(msg);
	}
	return value;
}

function crash(message)
{
	throw new Error(message);
}

return {
	crash: crash,
	log: F2(log)
};

}();var _elm_lang$core$Platform_Sub$batch = _elm_lang$core$Native_Platform.batch;
var _elm_lang$core$Platform_Sub$none = _elm_lang$core$Platform_Sub$batch(
	_elm_lang$core$Native_List.fromArray(
		[]));
var _elm_lang$core$Platform_Sub$map = _elm_lang$core$Native_Platform.map;
var _elm_lang$core$Platform_Sub$Sub = {ctor: 'Sub'};
var _elm_lang$core$Debug$crash = _elm_lang$core$Native_Debug.crash;
var _elm_lang$core$Debug$log = _elm_lang$core$Native_Debug.log;
var _user$project$Monoid$float = {
	zero: 0.0,
	op: F2(
		function (x, y) {
			return x + y;
		})
};
var _user$project$Monoid$int = {
	zero: 0,
	op: F2(
		function (x, y) {
			return x + y;
		})
};
var _user$project$Monoid$apply = F3(
	function (mon, a1, a2) {
		return A2(mon.op, a1, a2);
	});
var _user$project$Monoid$Monoid = F2(
	function (a, b) {
		return {zero: a, op: b};
	});
var _user$project$Monoid$Normal = function (a) {
	return {ctor: 'Normal', _0: a};
};
var _user$project$Monoid$Zero = {ctor: 'Zero'};
var _user$project$Monoid$appendZero = function (op) {
	var newOp = F2(
		function (a1, a2) {
			var _p0 = {ctor: '_Tuple2', _0: a1, _1: a2};
			if (_p0._0.ctor === 'Zero') {
				return _p0._1;
			} else {
				if (_p0._1.ctor === 'Zero') {
					return _p0._0;
				} else {
					return _user$project$Monoid$Normal(
						A2(op, _p0._0._0, _p0._1._0));
				}
			}
		});
	return {zero: _user$project$Monoid$Zero, op: newOp};
};
var _user$project$Finger$splitList = F4(
	function (folder, measurement, accumulator, listsplit) {
		splitList:
		while (true) {
			var newacc = A2(folder, listsplit.mid, accumulator);
			if (measurement(newacc)) {
				return _elm_lang$core$Maybe$Just(listsplit);
			} else {
				var _p0 = listsplit.right;
				if (_p0.ctor === '[]') {
					return _elm_lang$core$Maybe$Nothing;
				} else {
					var _v1 = folder,
						_v2 = measurement,
						_v3 = newacc,
						_v4 = {
						left: A2(
							_elm_lang$core$Basics_ops['++'],
							listsplit.left,
							_elm_lang$core$Native_List.fromArray(
								[listsplit.mid])),
						mid: _p0._0,
						right: _p0._1
					};
					folder = _v1;
					measurement = _v2;
					accumulator = _v3;
					listsplit = _v4;
					continue splitList;
				}
			}
		}
	});
var _user$project$Finger$toList = function (finger) {
	var _p1 = finger;
	switch (_p1.ctor) {
		case 'One':
			return _elm_lang$core$Native_List.fromArray(
				[_p1._0]);
		case 'Two':
			return _elm_lang$core$Native_List.fromArray(
				[_p1._0, _p1._1]);
		case 'Three':
			return _elm_lang$core$Native_List.fromArray(
				[_p1._0, _p1._1, _p1._2]);
		default:
			return _elm_lang$core$Native_List.fromArray(
				[_p1._0, _p1._1, _p1._2, _p1._3]);
	}
};
var _user$project$Finger$rightPeak = function (finger) {
	var _p2 = finger;
	switch (_p2.ctor) {
		case 'One':
			return _p2._0;
		case 'Two':
			return _p2._1;
		case 'Three':
			return _p2._2;
		default:
			return _p2._3;
	}
};
var _user$project$Finger$leftPeak = function (finger) {
	var _p3 = finger;
	switch (_p3.ctor) {
		case 'One':
			return _p3._0;
		case 'Two':
			return _p3._0;
		case 'Three':
			return _p3._0;
		default:
			return _p3._0;
	}
};
var _user$project$Finger$reduce = F3(
	function (f, zero, finger) {
		var _p4 = finger;
		switch (_p4.ctor) {
			case 'One':
				return A2(f, _p4._0, zero);
			case 'Two':
				return A2(
					f,
					_p4._1,
					A2(f, _p4._0, zero));
			case 'Three':
				return A2(
					f,
					_p4._2,
					A2(
						f,
						_p4._1,
						A2(f, _p4._0, zero)));
			default:
				return A2(
					f,
					_p4._3,
					A2(
						f,
						_p4._2,
						A2(
							f,
							_p4._1,
							A2(f, _p4._0, zero))));
		}
	});
var _user$project$Finger$ListSplit = F3(
	function (a, b, c) {
		return {left: a, mid: b, right: c};
	});
var _user$project$Finger$Four = F4(
	function (a, b, c, d) {
		return {ctor: 'Four', _0: a, _1: b, _2: c, _3: d};
	});
var _user$project$Finger$Three = F3(
	function (a, b, c) {
		return {ctor: 'Three', _0: a, _1: b, _2: c};
	});
var _user$project$Finger$Two = F2(
	function (a, b) {
		return {ctor: 'Two', _0: a, _1: b};
	});
var _user$project$Finger$leftAdd = F2(
	function (ana, finger) {
		var _p5 = finger;
		switch (_p5.ctor) {
			case 'One':
				return A2(_user$project$Finger$Two, ana, _p5._0);
			case 'Two':
				return A3(_user$project$Finger$Three, ana, _p5._0, _p5._1);
			case 'Three':
				return A4(_user$project$Finger$Four, ana, _p5._0, _p5._1, _p5._2);
			default:
				return finger;
		}
	});
var _user$project$Finger$rightAdd = F2(
	function (ana, finger) {
		var _p6 = finger;
		switch (_p6.ctor) {
			case 'One':
				return A2(_user$project$Finger$Two, _p6._0, ana);
			case 'Two':
				return A3(_user$project$Finger$Three, _p6._0, _p6._1, ana);
			case 'Three':
				return A4(_user$project$Finger$Four, _p6._0, _p6._1, _p6._2, ana);
			default:
				return finger;
		}
	});
var _user$project$Finger$One = function (a) {
	return {ctor: 'One', _0: a};
};
var _user$project$Finger$map = F2(
	function (f, finger) {
		var _p7 = finger;
		switch (_p7.ctor) {
			case 'One':
				return _user$project$Finger$One(
					f(_p7._0));
			case 'Two':
				return A2(
					_user$project$Finger$Two,
					f(_p7._0),
					f(_p7._1));
			case 'Three':
				return A3(
					_user$project$Finger$Three,
					f(_p7._0),
					f(_p7._1),
					f(_p7._2));
			default:
				return A4(
					_user$project$Finger$Four,
					f(_p7._0),
					f(_p7._1),
					f(_p7._2),
					f(_p7._3));
		}
	});
var _user$project$Finger$leftRemove = function (finger) {
	var _p8 = finger;
	switch (_p8.ctor) {
		case 'One':
			return finger;
		case 'Two':
			return _user$project$Finger$One(_p8._1);
		case 'Three':
			return A2(_user$project$Finger$Two, _p8._1, _p8._2);
		default:
			return A3(_user$project$Finger$Three, _p8._1, _p8._2, _p8._3);
	}
};
var _user$project$Finger$startSplit = function (finger) {
	var _p9 = finger;
	if (_p9.ctor === 'One') {
		return {
			left: _elm_lang$core$Native_List.fromArray(
				[]),
			mid: _p9._0,
			right: _elm_lang$core$Native_List.fromArray(
				[])
		};
	} else {
		return {
			left: _elm_lang$core$Native_List.fromArray(
				[]),
			mid: _user$project$Finger$leftPeak(finger),
			right: _user$project$Finger$toList(
				_user$project$Finger$leftRemove(finger))
		};
	}
};
var _user$project$Finger$split = F3(
	function (folder, measurement, accumulator) {
		return function (_p10) {
			return A4(
				_user$project$Finger$splitList,
				folder,
				measurement,
				accumulator,
				_user$project$Finger$startSplit(_p10));
		};
	});
var _user$project$Finger$rightRemove = function (finger) {
	var _p11 = finger;
	switch (_p11.ctor) {
		case 'One':
			return finger;
		case 'Two':
			return _user$project$Finger$One(_p11._0);
		case 'Three':
			return A2(_user$project$Finger$Two, _p11._0, _p11._1);
		default:
			return A3(_user$project$Finger$Three, _p11._0, _p11._1, _p11._2);
	}
};
var _user$project$Finger$tryFromList = function (list) {
	var _p12 = list;
	_v15_4:
	do {
		if (_p12.ctor === '::') {
			if (_p12._1.ctor === '[]') {
				return _elm_lang$core$Maybe$Just(
					_user$project$Finger$One(_p12._0));
			} else {
				if (_p12._1._1.ctor === '[]') {
					return _elm_lang$core$Maybe$Just(
						A2(_user$project$Finger$Two, _p12._0, _p12._1._0));
				} else {
					if (_p12._1._1._1.ctor === '[]') {
						return _elm_lang$core$Maybe$Just(
							A3(_user$project$Finger$Three, _p12._0, _p12._1._0, _p12._1._1._0));
					} else {
						if (_p12._1._1._1._1.ctor === '[]') {
							return _elm_lang$core$Maybe$Just(
								A4(_user$project$Finger$Four, _p12._0, _p12._1._0, _p12._1._1._0, _p12._1._1._1._0));
						} else {
							break _v15_4;
						}
					}
				}
			}
		} else {
			break _v15_4;
		}
	} while(false);
	return _elm_lang$core$Maybe$Nothing;
};
var _user$project$Node$startSplit = function (node) {
	var _p0 = node;
	if (_p0.ctor === 'Node2') {
		return {
			left: _elm_lang$core$Native_List.fromArray(
				[]),
			mid: _p0._0,
			right: _elm_lang$core$Native_List.fromArray(
				[_p0._1])
		};
	} else {
		return {
			left: _elm_lang$core$Native_List.fromArray(
				[]),
			mid: _p0._0,
			right: _elm_lang$core$Native_List.fromArray(
				[_p0._1, _p0._2])
		};
	}
};
var _user$project$Node$split = F4(
	function (start, folder, measurement, node) {
		var loop = F2(
			function (acc, split) {
				loop:
				while (true) {
					var newacc = A2(folder, split.mid, acc);
					if (measurement(newacc)) {
						return split;
					} else {
						var _p1 = split.right;
						if (_p1.ctor === '[]') {
							return split;
						} else {
							var _v2 = newacc,
								_v3 = {
								left: A2(
									_elm_lang$core$List$append,
									split.left,
									_elm_lang$core$Native_List.fromArray(
										[split.mid])),
								mid: _p1._0,
								right: _p1._1
							};
							acc = _v2;
							split = _v3;
							continue loop;
						}
					}
				}
			});
		return A2(
			loop,
			start,
			_user$project$Node$startSplit(node));
	});
var _user$project$Node$toFinger = function (node) {
	var _p2 = node;
	if (_p2.ctor === 'Node2') {
		return A2(_user$project$Finger$Two, _p2._0, _p2._1);
	} else {
		return A3(_user$project$Finger$Three, _p2._0, _p2._1, _p2._2);
	}
};
var _user$project$Node$reduce = F3(
	function (f, zero, node) {
		var _p3 = node;
		if (_p3.ctor === 'Node2') {
			return A2(
				f,
				_p3._1,
				A2(f, _p3._0, zero));
		} else {
			return A2(
				f,
				_p3._2,
				A2(
					f,
					_p3._1,
					A2(f, _p3._0, zero)));
		}
	});
var _user$project$Node$Node3 = F3(
	function (a, b, c) {
		return {ctor: 'Node3', _0: a, _1: b, _2: c};
	});
var _user$project$Node$Node2 = F2(
	function (a, b) {
		return {ctor: 'Node2', _0: a, _1: b};
	});
var _user$project$Node$map = F2(
	function (f, node) {
		var _p4 = node;
		if (_p4.ctor === 'Node2') {
			return A2(
				_user$project$Node$Node2,
				f(_p4._0),
				f(_p4._1));
		} else {
			return A3(
				_user$project$Node$Node3,
				f(_p4._0),
				f(_p4._1),
				f(_p4._2));
		}
	});
var _user$project$Internal$nodify = function (list) {
	var _p0 = list;
	if (_p0.ctor === '[]') {
		return _elm_lang$core$Native_List.fromArray(
			[]);
	} else {
		if (_p0._1.ctor === '[]') {
			return _elm_lang$core$Native_List.fromArray(
				[]);
		} else {
			if (_p0._1._1.ctor === '[]') {
				return _elm_lang$core$Native_List.fromArray(
					[
						A2(_user$project$Node$Node2, _p0._0, _p0._1._0)
					]);
			} else {
				if (_p0._1._1._1.ctor === '[]') {
					return _elm_lang$core$Native_List.fromArray(
						[
							A3(_user$project$Node$Node3, _p0._0, _p0._1._0, _p0._1._1._0)
						]);
				} else {
					return A2(
						_elm_lang$core$List_ops['::'],
						A2(_user$project$Node$Node2, _p0._0, _p0._1._0),
						_user$project$Internal$nodify(_p0._1._1));
				}
			}
		}
	}
};
var _user$project$Internal$rightPeak = function (fingerTree) {
	var _p1 = fingerTree;
	switch (_p1.ctor) {
		case 'Empty':
			return _elm_lang$core$Maybe$Nothing;
		case 'Single':
			return _elm_lang$core$Maybe$Just(_p1._0);
		default:
			return _elm_lang$core$Maybe$Just(
				_user$project$Finger$rightPeak(_p1._3));
	}
};
var _user$project$Internal$leftPeak = function (fingerTree) {
	var _p2 = fingerTree;
	switch (_p2.ctor) {
		case 'Empty':
			return _elm_lang$core$Maybe$Nothing;
		case 'Single':
			return _elm_lang$core$Maybe$Just(_p2._0);
		default:
			return _elm_lang$core$Maybe$Just(
				_user$project$Finger$leftPeak(_p2._0));
	}
};
var _user$project$Internal$reduce = F3(
	function (monoid, projection, fingerTree) {
		var f = function (_p3) {
			return monoid.op(
				projection(_p3));
		};
		var _p4 = fingerTree;
		switch (_p4.ctor) {
			case 'Empty':
				return monoid.zero;
			case 'Single':
				return A2(f, _p4._0, monoid.zero);
			default:
				var leftReduced = A3(_user$project$Finger$reduce, f, monoid.zero, _p4._0);
				var midReduced = A2(monoid.op, _p4._2, leftReduced);
				return A3(_user$project$Finger$reduce, f, midReduced, _p4._3);
		}
	});
var _user$project$Internal$Split = F3(
	function (a, b, c) {
		return {left: a, middle: b, right: c};
	});
var _user$project$Internal$Deep = F4(
	function (a, b, c, d) {
		return {ctor: 'Deep', _0: a, _1: b, _2: c, _3: d};
	});
var _user$project$Internal$Single = function (a) {
	return {ctor: 'Single', _0: a};
};
var _user$project$Internal$Empty = {ctor: 'Empty'};
var _user$project$Internal$empty = _user$project$Internal$Empty;
var _user$project$Internal$ofFinger = F2(
	function (zero, finger) {
		var _p5 = finger;
		switch (_p5.ctor) {
			case 'One':
				return _user$project$Internal$Single(_p5._0);
			case 'Two':
				return A4(
					_user$project$Internal$Deep,
					_user$project$Finger$One(_p5._0),
					_user$project$Internal$Empty,
					zero,
					_user$project$Finger$One(_p5._1));
			case 'Three':
				return A4(
					_user$project$Internal$Deep,
					A2(_user$project$Finger$Two, _p5._0, _p5._1),
					_user$project$Internal$Empty,
					zero,
					_user$project$Finger$One(_p5._2));
			default:
				return A4(
					_user$project$Internal$Deep,
					A2(_user$project$Finger$Two, _p5._0, _p5._1),
					_user$project$Internal$Empty,
					zero,
					A2(_user$project$Finger$Two, _p5._2, _p5._3));
		}
	});
var _user$project$Internal$leftPush = F4(
	function (monoid, projection, a0, fingerTree) {
		var zero = monoid.zero;
		var _p6 = fingerTree;
		switch (_p6.ctor) {
			case 'Empty':
				return _user$project$Internal$Single(a0);
			case 'Single':
				return A4(
					_user$project$Internal$Deep,
					_user$project$Finger$One(a0),
					_user$project$Internal$Empty,
					zero,
					_user$project$Finger$One(_p6._0));
			default:
				if (_p6._0.ctor === 'Four') {
					var node = A3(_user$project$Node$Node3, _p6._0._1, _p6._0._2, _p6._0._3);
					var nodeAnnotation = A3(
						_user$project$Node$reduce,
						function (_p7) {
							return monoid.op(
								projection(_p7));
						},
						zero,
						node);
					var midTree = A4(
						_user$project$Internal$leftPush,
						monoid,
						_elm_lang$core$Basics$snd,
						{ctor: '_Tuple2', _0: node, _1: nodeAnnotation},
						_p6._1);
					var midAnnotation = A3(_user$project$Internal$reduce, monoid, _elm_lang$core$Basics$snd, midTree);
					return A4(
						_user$project$Internal$Deep,
						A2(_user$project$Finger$Two, a0, _p6._0._0),
						midTree,
						midAnnotation,
						_p6._3);
				} else {
					return A4(
						_user$project$Internal$Deep,
						A2(_user$project$Finger$leftAdd, a0, _p6._0),
						_p6._1,
						_p6._2,
						_p6._3);
				}
		}
	});
var _user$project$Internal$leftPop = F2(
	function (mon, fingerTree) {
		var _p8 = fingerTree;
		switch (_p8.ctor) {
			case 'Empty':
				return _user$project$Internal$Empty;
			case 'Single':
				return _user$project$Internal$Empty;
			default:
				if (_p8._0.ctor === 'One') {
					var _p11 = _p8._3;
					var _p10 = _p8._1;
					var _p9 = _user$project$Internal$leftPeak(_p10);
					if (_p9.ctor === 'Just') {
						var newMid = A2(_user$project$Internal$leftPop, mon, _p10);
						return A4(
							_user$project$Internal$Deep,
							_user$project$Node$toFinger(_p9._0._0),
							newMid,
							A3(_user$project$Internal$reduce, mon, _elm_lang$core$Basics$snd, newMid),
							_p11);
					} else {
						return A2(_user$project$Internal$ofFinger, mon.zero, _p11);
					}
				} else {
					return A4(
						_user$project$Internal$Deep,
						_user$project$Finger$leftRemove(_p8._0),
						_p8._1,
						_p8._2,
						_p8._3);
				}
		}
	});
var _user$project$Internal$deepRight = F5(
	function (mon, left, mid, annotation, right) {
		var _p12 = _user$project$Finger$tryFromList(left);
		if (_p12.ctor === 'Just') {
			return A4(_user$project$Internal$Deep, _p12._0, mid, annotation, right);
		} else {
			var _p13 = _user$project$Internal$leftPeak(mid);
			if (_p13.ctor === 'Just') {
				var newmid = A2(_user$project$Internal$leftPop, mon, mid);
				return A4(
					_user$project$Internal$Deep,
					_user$project$Node$toFinger(_p13._0._0),
					newmid,
					A3(_user$project$Internal$reduce, mon, _elm_lang$core$Basics$snd, newmid),
					right);
			} else {
				return A2(_user$project$Internal$ofFinger, mon.zero, right);
			}
		}
	});
var _user$project$Internal$rightPush = F4(
	function (monoid, projection, a0, fingerTree) {
		var zero = monoid.zero;
		var _p14 = fingerTree;
		switch (_p14.ctor) {
			case 'Empty':
				return _user$project$Internal$Single(a0);
			case 'Single':
				return A4(
					_user$project$Internal$Deep,
					_user$project$Finger$One(_p14._0),
					_user$project$Internal$Empty,
					zero,
					_user$project$Finger$One(a0));
			default:
				if (_p14._3.ctor === 'Four') {
					var node = A3(_user$project$Node$Node3, _p14._3._0, _p14._3._1, _p14._3._2);
					var nodeAnnotation = A3(
						_user$project$Node$reduce,
						function (_p15) {
							return monoid.op(
								projection(_p15));
						},
						zero,
						node);
					var midTree = A4(
						_user$project$Internal$rightPush,
						monoid,
						_elm_lang$core$Basics$snd,
						{ctor: '_Tuple2', _0: node, _1: nodeAnnotation},
						_p14._1);
					var midAnnotation = A3(_user$project$Internal$reduce, monoid, _elm_lang$core$Basics$snd, midTree);
					return A4(
						_user$project$Internal$Deep,
						_p14._0,
						midTree,
						midAnnotation,
						A2(_user$project$Finger$Two, _p14._3._3, a0));
				} else {
					return A4(
						_user$project$Internal$Deep,
						_p14._0,
						_p14._1,
						_p14._2,
						A2(_user$project$Finger$rightAdd, a0, _p14._3));
				}
		}
	});
var _user$project$Internal$ofList = F3(
	function (monoid, projection, list) {
		return A3(
			_elm_lang$core$List$foldl,
			A2(_user$project$Internal$rightPush, monoid, projection),
			_user$project$Internal$empty,
			list);
	});
var _user$project$Internal$rightPop = F2(
	function (mon, fingerTree) {
		var _p16 = fingerTree;
		switch (_p16.ctor) {
			case 'Empty':
				return _user$project$Internal$Empty;
			case 'Single':
				return _user$project$Internal$Empty;
			default:
				if (_p16._3.ctor === 'One') {
					var _p19 = _p16._1;
					var _p18 = _p16._0;
					var _p17 = _user$project$Internal$rightPeak(_p19);
					if (_p17.ctor === 'Just') {
						var newMid = A2(_user$project$Internal$rightPop, mon, _p19);
						return A4(
							_user$project$Internal$Deep,
							_p18,
							newMid,
							A3(_user$project$Internal$reduce, mon, _elm_lang$core$Basics$snd, newMid),
							_user$project$Node$toFinger(_p17._0._0));
					} else {
						return A2(_user$project$Internal$ofFinger, mon.zero, _p18);
					}
				} else {
					return A4(
						_user$project$Internal$Deep,
						_p16._0,
						_p16._1,
						_p16._2,
						_user$project$Finger$rightRemove(_p16._3));
				}
		}
	});
var _user$project$Internal$deepLeft = F5(
	function (mon, left, mid, annotation, right) {
		var _p20 = _user$project$Finger$tryFromList(right);
		if (_p20.ctor === 'Just') {
			return A4(_user$project$Internal$Deep, left, mid, annotation, _p20._0);
		} else {
			var _p21 = _user$project$Internal$rightPeak(mid);
			if (_p21.ctor === 'Just') {
				var newmid = A2(_user$project$Internal$rightPop, mon, mid);
				return A4(
					_user$project$Internal$Deep,
					left,
					newmid,
					A3(_user$project$Internal$reduce, mon, _elm_lang$core$Basics$snd, newmid),
					_user$project$Node$toFinger(_p21._0._0));
			} else {
				return A2(_user$project$Internal$ofFinger, mon.zero, left);
			}
		}
	});
var _user$project$Internal$concatWithMiddle = F5(
	function (monoid, projection, left, middle, right) {
		var rPush = A2(_user$project$Internal$rightPush, monoid, projection);
		var lPush = A2(_user$project$Internal$leftPush, monoid, projection);
		var annotate = function (node) {
			return {
				ctor: '_Tuple2',
				_0: node,
				_1: A3(
					_user$project$Node$reduce,
					function (_p22) {
						return monoid.op(
							projection(_p22));
					},
					monoid.zero,
					node)
			};
		};
		var loop = F3(
			function (l, m, r) {
				var _p23 = {ctor: '_Tuple3', _0: l, _1: m, _2: r};
				switch (_p23._0.ctor) {
					case 'Empty':
						if (_p23._1.ctor === '[]') {
							return _p23._2;
						} else {
							return A2(
								lPush,
								_p23._1._0,
								A3(loop, _user$project$Internal$Empty, _p23._1._1, _p23._2));
						}
					case 'Single':
						return A2(
							lPush,
							_p23._0._0,
							A3(loop, _user$project$Internal$Empty, _p23._1, _p23._2));
					default:
						switch (_p23._2.ctor) {
							case 'Empty':
								var _p25 = _p23._0;
								var _p24 = _elm_lang$core$List$reverse(_p23._1);
								if (_p24.ctor === '[]') {
									return _p25;
								} else {
									return A2(
										rPush,
										_p24._0,
										A3(
											loop,
											_p25,
											_elm_lang$core$List$reverse(_p24._1),
											_user$project$Internal$Empty));
								}
							case 'Single':
								return A2(
									rPush,
									_p23._2._0,
									A3(loop, _p23._0, _p23._1, _user$project$Internal$Empty));
							default:
								var newMidList = A2(
									_elm_lang$core$List$map,
									annotate,
									_user$project$Internal$nodify(
										A2(
											_elm_lang$core$Basics_ops['++'],
											_user$project$Finger$toList(_p23._0._3),
											A2(
												_elm_lang$core$Basics_ops['++'],
												_p23._1,
												_user$project$Finger$toList(_p23._2._0)))));
								var newMidTree = A5(_user$project$Internal$concatWithMiddle, monoid, _elm_lang$core$Basics$snd, _p23._0._1, newMidList, _p23._2._1);
								return A4(
									_user$project$Internal$Deep,
									_p23._0._0,
									newMidTree,
									A3(_user$project$Internal$reduce, monoid, _elm_lang$core$Basics$snd, newMidTree),
									_p23._2._3);
						}
				}
			});
		return A3(loop, left, middle, right);
	});
var _user$project$Internal$concat = F4(
	function (monoid, projection, left, right) {
		return A5(
			_user$project$Internal$concatWithMiddle,
			monoid,
			projection,
			left,
			_elm_lang$core$Native_List.fromArray(
				[]),
			right);
	});
var _user$project$Internal$split = F5(
	function (monoid, projection, measurement, start, tree) {
		var folder = F2(
			function (a, b) {
				return A2(
					monoid.op,
					b,
					projection(a));
			});
		var red = A2(_user$project$Internal$reduce, monoid, _elm_lang$core$Basics$snd);
		var deepL = _user$project$Internal$deepLeft(monoid);
		var deepR = _user$project$Internal$deepRight(monoid);
		var fromList = A2(_user$project$Internal$ofList, monoid, projection);
		var _p26 = tree;
		switch (_p26.ctor) {
			case 'Single':
				var _p27 = _p26._0;
				return measurement(
					A2(folder, _p27, start)) ? _elm_lang$core$Maybe$Just(
					{left: _user$project$Internal$Empty, middle: _p27, right: _user$project$Internal$Empty}) : _elm_lang$core$Maybe$Nothing;
			case 'Deep':
				var _p38 = _p26._3;
				var _p37 = _p26._1;
				var _p36 = _p26._0;
				var _p35 = _p26._2;
				var _p28 = A4(_user$project$Finger$split, folder, measurement, start, _p36);
				if (_p28.ctor === 'Just') {
					var _p29 = _p28._0;
					return _elm_lang$core$Maybe$Just(
						{
							left: fromList(_p29.left),
							middle: _p29.mid,
							right: A4(deepR, _p29.right, _p37, _p35, _p38)
						});
				} else {
					var leftReduced = A3(_user$project$Finger$reduce, folder, start, _p36);
					var _p30 = A5(_user$project$Internal$split, monoid, _elm_lang$core$Basics$snd, measurement, leftReduced, _p37);
					if (_p30.ctor === 'Just') {
						var _p32 = _p30._0;
						var _p31 = _p32.middle;
						var node = _p31._0;
						var upToNode = A2(
							monoid.op,
							leftReduced,
							red(_p32.left));
						var splitNode = A4(_user$project$Node$split, upToNode, folder, measurement, node);
						var splitLeft = A4(
							deepL,
							_p36,
							_p32.left,
							red(_p32.left),
							splitNode.left);
						var splitRight = A4(
							deepR,
							splitNode.right,
							_p32.right,
							red(_p32.right),
							_p38);
						return _elm_lang$core$Maybe$Just(
							{left: splitLeft, middle: splitNode.mid, right: splitRight});
					} else {
						var midReduced = A2(monoid.op, leftReduced, _p35);
						var _p33 = A4(_user$project$Finger$split, folder, measurement, midReduced, _p38);
						if (_p33.ctor === 'Just') {
							var _p34 = _p33._0;
							return _elm_lang$core$Maybe$Just(
								{
									left: A4(deepL, _p36, _p37, _p35, _p34.left),
									middle: _p34.mid,
									right: fromList(_p34.right)
								});
						} else {
							return _elm_lang$core$Maybe$Nothing;
						}
					}
				}
			default:
				return _elm_lang$core$Maybe$Nothing;
		}
	});
var _user$project$Annotated$annotate = F2(
	function (aft, asplit) {
		return {
			left: _elm_lang$core$Native_Utils.update(
				aft,
				{tree: asplit.left}),
			middle: asplit.middle,
			right: _elm_lang$core$Native_Utils.update(
				aft,
				{tree: asplit.right})
		};
	});
var _user$project$Annotated$split = F2(
	function (measure, aft) {
		return A2(
			_elm_lang$core$Maybe$map,
			_user$project$Annotated$annotate(aft),
			A5(_user$project$Internal$split, aft.monoid, aft.projection, measure, aft.monoid.zero, aft.tree));
	});
var _user$project$Annotated$get = function (measure) {
	return function (_p0) {
		return A2(
			_elm_lang$core$Maybe$map,
			function (_) {
				return _.middle;
			},
			A2(_user$project$Annotated$split, measure, _p0));
	};
};
var _user$project$Annotated$before = F2(
	function (measure, aft) {
		var _p1 = A2(_user$project$Annotated$split, measure, aft);
		if (_p1.ctor === 'Just') {
			return _p1._0.left;
		} else {
			return _elm_lang$core$Native_Utils.update(
				aft,
				{tree: _user$project$Internal$Empty});
		}
	});
var _user$project$Annotated$after = F2(
	function (measure, aft) {
		var _p2 = A2(_user$project$Annotated$split, measure, aft);
		if (_p2.ctor === 'Just') {
			return _p2._0.right;
		} else {
			return _elm_lang$core$Native_Utils.update(
				aft,
				{tree: _user$project$Internal$Empty});
		}
	});
var _user$project$Annotated$concatWithMiddle = F3(
	function (l, m, r) {
		return _elm_lang$core$Native_Utils.update(
			l,
			{
				tree: A5(_user$project$Internal$concatWithMiddle, l.monoid, l.projection, l.tree, m, r.tree)
			});
	});
var _user$project$Annotated$set = F2(
	function (measure, value) {
		var rebuild = function (asplit) {
			return A3(
				_user$project$Annotated$concatWithMiddle,
				asplit.left,
				_elm_lang$core$Native_List.fromArray(
					[value]),
				asplit.right);
		};
		return function (_p3) {
			return A2(
				_elm_lang$core$Maybe$map,
				rebuild,
				A2(_user$project$Annotated$split, measure, _p3));
		};
	});
var _user$project$Annotated$insert = F2(
	function (measure, value) {
		var rebuild = function (asplit) {
			return A3(
				_user$project$Annotated$concatWithMiddle,
				asplit.left,
				_elm_lang$core$Native_List.fromArray(
					[value, asplit.middle]),
				asplit.right);
		};
		return function (_p4) {
			return A2(
				_elm_lang$core$Maybe$map,
				rebuild,
				A2(_user$project$Annotated$split, measure, _p4));
		};
	});
var _user$project$Annotated$concat = F2(
	function (l, r) {
		return _elm_lang$core$Native_Utils.update(
			l,
			{
				tree: A4(_user$project$Internal$concat, l.monoid, l.projection, l.tree, r.tree)
			});
	});
var _user$project$Annotated$remove = function (measure) {
	return function (_p5) {
		return A2(
			_elm_lang$core$Maybe$map,
			function (asplit) {
				return A2(_user$project$Annotated$concat, asplit.left, asplit.right);
			},
			A2(_user$project$Annotated$split, measure, _p5));
	};
};
var _user$project$Annotated$rightPush = F2(
	function (ana, aft) {
		return _elm_lang$core$Native_Utils.update(
			aft,
			{
				tree: A4(_user$project$Internal$rightPush, aft.monoid, aft.projection, ana, aft.tree)
			});
	});
var _user$project$Annotated$upTo = F2(
	function (measure, aft) {
		var _p6 = A2(_user$project$Annotated$split, measure, aft);
		if (_p6.ctor === 'Just') {
			var _p7 = _p6._0;
			return A2(_user$project$Annotated$rightPush, _p7.middle, _p7.left);
		} else {
			return _elm_lang$core$Native_Utils.update(
				aft,
				{tree: _user$project$Internal$Empty});
		}
	});
var _user$project$Annotated$rightPop = function (aft) {
	return _elm_lang$core$Native_Utils.update(
		aft,
		{
			tree: A2(_user$project$Internal$rightPop, aft.monoid, aft.tree)
		});
};
var _user$project$Annotated$rightPeek = function (_p8) {
	return _user$project$Internal$rightPeak(
		function (_) {
			return _.tree;
		}(_p8));
};
var _user$project$Annotated$leftPush = F2(
	function (ana, aft) {
		return _elm_lang$core$Native_Utils.update(
			aft,
			{
				tree: A4(_user$project$Internal$leftPush, aft.monoid, aft.projection, ana, aft.tree)
			});
	});
var _user$project$Annotated$from = F2(
	function (measure, aft) {
		var _p9 = A2(_user$project$Annotated$split, measure, aft);
		if (_p9.ctor === 'Just') {
			var _p10 = _p9._0;
			return A2(_user$project$Annotated$leftPush, _p10.middle, _p10.right);
		} else {
			return _elm_lang$core$Native_Utils.update(
				aft,
				{tree: _user$project$Internal$Empty});
		}
	});
var _user$project$Annotated$leftPop = function (aft) {
	return _elm_lang$core$Native_Utils.update(
		aft,
		{
			tree: A2(_user$project$Internal$leftPop, aft.monoid, aft.tree)
		});
};
var _user$project$Annotated$leftPeek = function (_p11) {
	return _user$project$Internal$leftPeak(
		function (_) {
			return _.tree;
		}(_p11));
};
var _user$project$Annotated$reduce = function (aft) {
	return A3(_user$project$Internal$reduce, aft.monoid, aft.projection, aft.tree);
};
var _user$project$Annotated$AnnotatedFingerTree = F3(
	function (a, b, c) {
		return {monoid: a, projection: b, tree: c};
	});
var _user$project$Annotated$empty = F2(
	function (monoid, projection) {
		return A3(_user$project$Annotated$AnnotatedFingerTree, monoid, projection, _user$project$Internal$empty);
	});
var _user$project$Annotated$Split = F3(
	function (a, b, c) {
		return {left: a, middle: b, right: c};
	});
var _user$project$Container$insert = function (_p0) {
	return _user$project$Annotated$insert(
		F2(
			function (x, y) {
				return _elm_lang$core$Native_Utils.cmp(x, y) < 0;
			})(_p0));
};
var _user$project$Container$remove = function (_p1) {
	return _user$project$Annotated$remove(
		F2(
			function (x, y) {
				return _elm_lang$core$Native_Utils.cmp(x, y) < 0;
			})(_p1));
};
var _user$project$Container$set = function (_p2) {
	return _user$project$Annotated$set(
		F2(
			function (x, y) {
				return _elm_lang$core$Native_Utils.cmp(x, y) < 0;
			})(_p2));
};
var _user$project$Container$get = function (_p3) {
	return _user$project$Annotated$get(
		F2(
			function (x, y) {
				return _elm_lang$core$Native_Utils.cmp(x, y) < 0;
			})(_p3));
};
var _user$project$Container$size = _user$project$Annotated$reduce;
var _user$project$Container$slice = F3(
	function (start, end, con) {
		var length = _user$project$Container$size(con);
		var index = function (n) {
			index:
			while (true) {
				if (_elm_lang$core$Native_Utils.cmp(n, 0 - length) < 0) {
					var _v0 = 0;
					n = _v0;
					continue index;
				} else {
					if (_elm_lang$core$Native_Utils.cmp(n, 0) < 0) {
						var _v1 = length + n;
						n = _v1;
						continue index;
					} else {
						if (_elm_lang$core$Native_Utils.cmp(n, length) > -1) {
							return length - 1;
						} else {
							return n;
						}
					}
				}
			}
		};
		return A2(
			_user$project$Annotated$before,
			function (_p4) {
				return A2(
					F2(
						function (x, y) {
							return _elm_lang$core$Native_Utils.cmp(x, y) < 0;
						}),
					end - start,
					index(_p4));
			},
			A2(
				_user$project$Annotated$from,
				function (_p5) {
					return A2(
						F2(
							function (x, y) {
								return _elm_lang$core$Native_Utils.cmp(x, y) < 0;
							}),
						start,
						index(_p5));
				},
				con));
	});
var _user$project$Container$peekBack = _user$project$Annotated$rightPeek;
var _user$project$Container$popBack = _user$project$Annotated$rightPop;
var _user$project$Container$pushBack = _user$project$Annotated$rightPush;
var _user$project$Container$peekFront = _user$project$Annotated$leftPeek;
var _user$project$Container$popFront = _user$project$Annotated$leftPop;
var _user$project$Container$pushFront = _user$project$Annotated$leftPush;
var _user$project$Container$empty = A2(
	_user$project$Annotated$empty,
	_user$project$Monoid$int,
	_elm_lang$core$Basics$always(1));
var _user$project$Container$fromList = A2(_elm_lang$core$List$foldl, _user$project$Container$pushBack, _user$project$Container$empty);
var Elm = {};
Elm['Container'] = Elm['Container'] || {};
_elm_lang$core$Native_Platform.addPublicModule(Elm['Container'], 'Container', typeof _user$project$Container$main === 'undefined' ? null : _user$project$Container$main);

if (typeof define === "function" && define['amd'])
{
  define([], function() { return Elm; });
  return;
}

if (typeof module === "object")
{
  module['exports'] = Elm;
  return;
}

var globalElm = this['Elm'];
if (typeof globalElm === "undefined")
{
  this['Elm'] = Elm;
  return;
}

for (var publicModule in Elm)
{
  if (publicModule in globalElm)
  {
    throw new Error('There are two Elm modules called `' + publicModule + '` on this page! Rename one of them.');
  }
  globalElm[publicModule] = Elm[publicModule];
}

}).call(this);
</script></head><body><script type="text/javascript">Elm.Container.fullscreen()</script></body></html>